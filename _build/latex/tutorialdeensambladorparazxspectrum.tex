%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,spanish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsspanish{\renewcommand{\contentsname}{Contenidos:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Tutorial de ensamblador para ZX Spectrum}
\date{04 de marzo de 2021}
\release{1.0}
\author{Compiler Software}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Versión}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Prólogo}
\label{\detokenize{01_prologo/prologo:prologo}}\label{\detokenize{01_prologo/prologo::doc}}
Mucha gente se preguntará cómo es posible que, en pleno 2011, exista alguien con interés en escribir y publicar un curso sobre esta temática. Apenas un par de centenares o miles de personas en todo el mundo pueden estar realmente interesadas en la lectura de un curso como este.

Sin embargo, he dedicado gran cantidad de horas a escribir y depurar este texto y sus ejemplos. ¿El motivo? Simplemente, no se me ocurre una mejor forma de concentrar en un único elemento mi pasión por el ZX Spectrum, la programación en ensamblador, el desarrollo de programas y los videojuegos.

Puedo y debo decir que el ZX Spectrum cambió mi vida. Aquella tarde de viernes de 1989 en la que mis padres aparecieron por la puerta con un Spectrum +2A de segunda mano, junto a una caja llena de revistas Microhobby y cintas de juegos y programas, cambió el que hubiera sido mi futuro profesional, orientándolo hacia el mundo de la Ingeniería, la Electrónica y las Telecomunicaciones.

Como todos, empecé exprimiendo el Spectrum a través de los juegos profesionales que se vendían para la popular máquina de Sinclair. En paralelo a los juegos, comencé a leer los ejemplares de las revistas Microhobby que habíamos adquirido junto al ordenador.

Mi relación inicial con Microhobby fue las que supongo que tendrían muchos usuarios sin interés por la programación: directo a las páginas con análisis, fotos y notas de juegos. Como mucho, como curiosidad tecleaba alguno de los listados en BASIC de la sección de trucos, maravillándome con sencillas melodías, o psicodélicos efectos de colores con el borde.

Esos listados en BASIC, tan sencillos, despertaron mi curiosidad por «cómo se hacen estos juegos». Poco a poco se produjo el cambio: mi interés por jugar pasó a ser interés, mucho interés, por desarrollar.

Microhobby fue la herramienta mediante la cual aprendí BASIC y ensamblador de Z80. Como la completa revista que era, entre sus páginas de análisis de juegos podías encontrar fantásticos artículos y listados animándote a programar pequeñas rutinas y juegos.

Casi sin darme tiempo para disfrutar de lo que estaba aprendiendo, llegó el fin de la revista Microhobby y el ocaso comercial del Spectrum en España. Las consolas ocuparon el espacio lúdico del Spectrum y el PC se convirtió en la herramienta de programación estándar. El Spectrum pasó para mí al olvido hasta que la revista Micromanía publicó el emulador «SPECTRUM» de Pedro Gimeno.

Este emulador, y todos los que aparecieron en la década de los 90, sirvió para que la gente no olvidara el Spectrum y todo el legado que nos había dejado.

Ya a principios del siglo XXI, el Spectrum volvió a ser mi centro de atención: inicialmente, desarrollé el emulador ASpectrum con el que mejoré en gran parte mis conocimientos sobre la arquitectura del Spectrum y la programación en lenguaje ensamblador de Z80.

Una vez ASpectrum fue una realidad, comencé a realizar sencillos juegos con Z88DK en C con pequeñas rutinas en ensamblador integradas en el código. Se despertó de nuevo en mí el interés por desarrollar juegos de Spectrum y de escribir tutoriales y cursos con todo lo que iba rememorando o aprendiendo.

En esa época (años 2002 \sphinxhyphen{} 2003) se fundó Compiler Software y se editó la revista MagazineZX en el portal Speccy.org, incluyendo diversos cursos de programación en C con Z88DK y en ensamblador de Z80 con pasmo. Estos cursos, finalmente, se han ampliado y materializado en el texto que estáis leyendo.


\section{Objetivos y desarrollo del curso}
\label{\detokenize{01_prologo/prologo:objetivos-y-desarrollo-del-curso}}
El objetivo principal de este curso, libro, o gran tutorial es que un lector con conocimientos básicos de programación pueda aprender fácilmente ensamblador de Z80 aplicado al desarrollo de juegos y utilidades de Spectrum.

Con este curso pretendemos enseñar al lector:
\begin{itemize}
\item {} 
La arquitectura del Sinclair ZX Spectrum: se describen sus componentes internos y cómo se interrelacionan.

\item {} 
La arquitectura del microprocesador Z80: sus registros y su juego de instrucciones.

\item {} 
La sintaxis del lenguaje ensamblador de Z80: nmemónicos del lenguaje.

\item {} 
Cómo utilizar el ensamblador PASMO para ensamblar nuestros programas en ASM de Z80.

\item {} 
Acceso a los periféricos del Spectrum: Teclado, Joystick, etc.

\item {} 
Gráficos en el Spectrum: Sprites, Fuentes de texto, Impresión de mapeados, etc.

\item {} 
Funciones avanzadas de los modelos 128K: paginación de memoria.

\item {} 
Rutinas auxiliares: subrutinas de carga, compresión RLE, interrupciones del procesador.

\item {} 
Subrutinas útiles para el desarrollo de programas.

\end{itemize}

Al escribirlo he intentado ponerme en la piel del programador que desea empezar con el lenguaje ensamblador, por lo que los dos primeros capítulos describen la arquitectura del Spectrum y del Z80. Los siguientes cinco capítulos tratan sobre la sintaxis del lenguaje ensamblador, donde el lector aprenderá las «piezas básicas» con las que construir programas en ensamblador para cualquier microordenador basado en el procesador Z80 de Zilog.

A partir del octavo capítulo nos centramos única y exclusivamente en el Spectrum, profundizando en todas las diferentes áreas que puedan sernos de utilidad para el desarrollo de juegos o programas: lectura del teclado, temporización, impresión de gráficos, técnicas de mapeado, carga desde cinta, etc.

A lo largo del texto se presentan múltiples ejemplos y rutinas para que el lector pueda verificar la teoría descrita así como utilizarlas directamente en sus propios programas.

Cuando se escribe una rutina para un procesador tan «limitado» como el Z80 suelen presentarse 2 opciones: escribir una rutina comprensible, o escribir una rutina optimizada. El objetivo del curso es que el lector aprenda programación en ensamblador y por lo tanto debe de poder comprender las rutinas que se presentan, por lo que en el desarrollo de los ejemplos y las rutinas ha primado la comprensión frente a la optimización en aquellos casos en que ambas opciones chocaban.

Esto no quiere decir que las rutinas no sean óptimas: al contrario, se han diseñado para que sean siempre lo más óptimas posible siempre y cuando eso no implique hacerlas incomprensibles para el lector. Aún así, un programador avanzado podrá (y deberá) darles una pequeña vuelta de tuerca adicional para exprimir ciclos de reloj a la rutina y hacerla aún un poco más rápida. Ese podría ser el objetivo del lector una vez acabado el curso y de cara al diseño de un programa.

Si un lector sin conocimientos de ensamblador, tras leer el curso, acaba decidiendo programar un juego y utiliza o mejora las rutinas que se presentan en este texto, podremos decir que el curso ha conseguido su objetivo.

Espero que disfrutéis tanto leyéndolo como yo escribiéndolo.


\chapter{Introducción y conceptos básicos}
\label{\detokenize{02_introduccion/introduccion:introduccion-y-conceptos-basicos}}\label{\detokenize{02_introduccion/introduccion::doc}}

\section{Los límites de BASIC}
\label{\detokenize{02_introduccion/introduccion:los-limites-de-basic}}
Todo aquel lector que haya programado en BASIC conocerá sin duda la principal limitación de este sencillo lenguaje de alto nivel: es lento, muy lento. A cambio de su sencillez pagamos una penalización enorme en velocidad.

BASIC es un lenguaje interpretado, lo que quiere decir que el Spectrum (más bien el intérprete BASIC integrado en la ROM) tiene que leer línea a línea nuestro programa, decodificar lo que estamos diciendo en lenguaje BASIC, traducirlo a instrucciones comprensibles por el procesador y ejecutarlo, todo ello en tiempo real.

Eso implica que cada vez que se ejecuta el programa BASIC, para cada línea del programa se ejecuta un proceso de lectura, decodificación, traducción y ejecución. Este proceso es lento e implica que no sólo se está ejecutando nuestro programa sino que debajo de él tenemos al intérprete de BASIC realizando todas estas tareas y restándonos parte de la potencia de CPU del Spectrum, que ya de por sí no es especialmente potente.

No importa lo elegantemente optimizado que esté nuestro programa en BASIC, el proceso de interpretación en sí hará que se ejecute con una lentitud que no podemos salvar.

BASIC tiene una serie de trucos más o menos conocidos para acelerar su ejecución: escribir muchas instrucciones en una sóla línea BASIC, poner las rutinas que más velocidad necesitan en las primeras líneas de programa, reducir el nombre (en longitud) de las variables, etc. Pero al final llegamos a un punto en que no podemos mejorar nuestros programas en cuanto a velocidad.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{basic}.png}
\caption{El editor del intérprete de BASIC}\label{\detokenize{02_introduccion/introduccion:id2}}\end{figure}


\section{Los límites de BASIC}
\label{\detokenize{02_introduccion/introduccion:id1}}
Todos aquel lector que haya programado en BASIC conocerá sin duda la principal limitación de este sencillo lenguaje de alto nivel: es lento, muy lento. A cambio de su sencillez pagamos una penalización enorme en velocidad.

BASIC es un lenguaje interpretado, lo que quiere decir que el Spectrum (más bien el intérprete BASIC integrado en la ROM) tiene que leer línea a línea nuestro programa, decodificar lo que estamos diciendo en lenguaje BASIC, traducirlo a instrucciones comprensibles por el procesador y ejecutarlo, todo ello en tiempo real.

Eso implica que cada vez que se ejecuta el programa BASIC, para cada línea del programa se ejecuta un proceso de lectura, decodificación, traducción y ejecución. Este proceso es lento e implica que no sólo se está ejecutando nuestro programa sino que debajo de él tenemos al intérprete de BASIC realizando todas estas tareas y restándonos parte de la potencia de CPU del Spectrum, que ya de por sí no es especialmente potente.

No importa lo elegantemente optimizado que esté nuestro programa en BASIC, el proceso de interpretación en sí hará que se ejecute con una lentitud que no podemos salvar.

BASIC tiene una serie de trucos más o menos conocidos para acelerar su ejecución: escribir muchas instrucciones en una sóla línea BASIC, poner las rutinas que más velocidad necesitan en las primeras líneas de programa, reducir el nombre (en longitud) de las variables, etc. Pero al final llegamos a un punto en que no podemos mejorar nuestros programas en cuanto a velocidad.

Lenguaje BASIC y su intérprete
El editor del intérprete de BASIC

Para muchos, el BASIC del Spectrum es un comienzo prácticamente obligado para programar, pero si queremos realizar programas con la calidad del software comercial no puede ser la herramienta a utilizar. Dejando de lado que sigue siendo una herramienta muy útil para programar en el Spectrum, para muchos llega la hora de dar el siguiente paso.


\section{Alternativas a BASIC}
\label{\detokenize{02_introduccion/introduccion:alternativas-a-basic}}
Aparte de realizar programas para el intérprete de BASIC existen múltiples alternativas para programar juegos y aplicaciones que expriman al máximo nuestra máquina:


\section{Subrutinas en ensamblador dentro de un programa BASIC}
\label{\detokenize{02_introduccion/introduccion:subrutinas-en-ensamblador-dentro-de-un-programa-basic}}
Para empezar, como primera opción, podemos realizar pequeñas rutinas en ensamblador y utilizarlas desde nuestros programas en BASIC. El lenguaje ensamblador se trata del lenguaje más cercano a lo que es el código binario que entiende directamente un microprocesador. Es de bajo nivel, es decir, está más lejos del lenguaje humano de lo que está BASIC, y a la vez está muy cerca del lenguaje que entiende el microprocesador de nuestro Spectrum.

En BASIC, una instrucción es traducida por el intérprete BASIC a una serie más o menos larga de comandos en lenguaje máquina. Por ejemplo, 10 PRINT «HOLA», se traduce como una serie de comandos en lenguaje máquina que podrían ser algo como «para cada una de las letras de la palabra HOLA, realiza todas las operaciones necesarias para mostrar en pantalla todos los píxels que forman dichas letras, actualizando la posición del cursor y usando el color INK y PAPER actual».

Una instrucción BASIC equivale a una gran cantidad de instrucciones en código máquina.

Por contra, una instrucción en lenguaje ensamblador equivale a una sóla instrucción en lenguaje máquina: hablamos directamente el lenguaje de la máquina, sólo que en vez de hacerlo con unos y ceros, lo hacemos en un lenguaje que tiene unas determinadas reglas de sintaxis y que el «programa ensamblador» se encarga de traducir a código máquina. Es por eso que programar en ensamblador es de «bajo nivel»: hablamos directamente al nivel de la máquina, y por eso mismo los programas son más complicados de escribir, de leer y de mantener que un programa en BASIC, donde se habla un lenguaje más natural y que es traducido a lo que la máquina entiende.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{;}
\PYG{c+c1}{; Rutina de multiplicación en lenguaje ensamblador:}
\PYG{c+c1}{;}
\PYG{c+c1}{; MULTIPLICA: Multiplica DE*BC}
\PYG{c+c1}{;}
\PYG{c+c1}{;       Entrada:        DE: Multiplicando,}
\PYG{c+c1}{;                       BC: Multiplicador}
\PYG{c+c1}{;       Salida:         HL: Resultado.}

\PYG{n+nl}{MULTIPLICA:}
        \PYG{n+nf}{LD} \PYG{n+nv}{HL}\PYG{p}{,} \PYG{l+m+mi}{0}            \PYG{c+c1}{; HL = 0}
\PYG{n+nl}{MULTI01:}
        \PYG{n+nf}{ADD} \PYG{n+nv}{HL}\PYG{p}{,} \PYG{n+nv}{DE}          \PYG{c+c1}{; Sumamos HL = HL + DE}
        \PYG{n+nf}{DEC} \PYG{n+nv}{BC}
        \PYG{n+nf}{LD} \PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}
        \PYG{n+nf}{OR} \PYG{n+nv}{C}
        \PYG{n+nf}{JR} \PYG{n+nv}{NZ}\PYG{p}{,} \PYG{n+nv}{MULTI01}      \PYG{c+c1}{; Lo repetimos BC veces}
        \PYG{n+nf}{RET}                 \PYG{c+c1}{; Volver de la rutina}
\end{sphinxVerbatim}

La primera de las opciones que estamos tratando, la de programar rutinas en ensamblador y utilizarlas después desde programas en BASIC seguiría el siguiente ciclo de desarrollo:
\begin{itemize}
\item {} 
Programamos una rutina en lenguaje ensamblador que realice una función concreta: por ejemplo, dibujar el personaje o enemigos de nuestro juego, borrar la pantalla, actualizar los marcadores, etc.

\item {} 
Ensamblamos la rutina con un programa ensamblador y obtenemos un bloque de datos que contiene la traducción del programa que hemos escrito a código máquina directamente comprensible por el microprocesador.

\item {} 
Cargamos en memoria el bloque de datos de código máquina que acabamos de obtener mediante un LOAD «» CODE o POKEando cada byte de este bloque de datos en memoria.

\item {} 
Programamos nuestro programa en BASIC, y llamamos a la rutina que hemos programando cuando la necesitemos utilizando RANDOMIZE USR hacia la dirección en que hemos cargado o POKEado la rutina.

\end{itemize}

Es decir: realizamos una rutina o un conjunto de rutinas en ensamblador y mediante un programa ensamblador, traducimos el código ASM a código que entiende directamente la máquina (código binario) y lo salvamos en cinta (o si es corto, anotamos sus valores para meterlos en DATAs). Después, al inicio de nuestro programa, introducimos ese código binario en memoria de forma que lo podamos llamar en cualquier momento desde BASIC con RANDOMIZE USR.

Esto permite realizar rutinas importantes y críticas en lenguaje ensamblador, y mantener el esqueleto del programa principal en BASIC. Las rutinas creadas en ensamblador son llamadas desde BASIC con la instrucción \sphinxstylestrong{USR} en aquellos puntos del programa en que las necesitemos.

Más adelante en este capítulo veremos un ejemplo de cómo realizar el ensamblado de una rutina en ensamblador, su carga en memoria y su utilización desde un programa en BASIC.


\section{Compilando el programa BASIC con un compilador}
\label{\detokenize{02_introduccion/introduccion:compilando-el-programa-basic-con-un-compilador}}
Aunque utilicemos rutinas en ensamblador llamadas desde BASIC, seguiremos lastrados por la velocidad del intérprete y los tiempos de ejecución de las partes del programa que no están escritas en ensamblador.

Como una segunda opción alternativa a la integración BASIC\sphinxhyphen{}ASM, tenemos la opción de utilizar un compilador de BASIC para compilar nuestros programas y traducirlos a código máquina sin pasar por ningún intérprete de BASIC.

Mediante un compilador de BASIC, a partir de un programa de código fuente en BASIC obtenemos un ejecutable que podremos cargar directamente en memoria y ejecutarlo sin necesidad de utilizar el intérprete del sistema.

La labor de interpretación del código BASIC se hace igualmente, pero se hace antes, ya que en lugar de ejecutar, el resultado de la interpretación se graba ya «traducido» en cinta. Un programa en BASIC compilado y ejecutado de este modo es muchísimo más rápido que el mismo programa ejecutado en el intérprete de BASIC del Spectrum.

\sphinxstylestrong{MCODER}, uno de los compiladores nativos de BASIC más conocidos, es una buena solución, y para muchos puede ser suficiente para muchas de sus creaciones. Nuestra querida DINAMIC realizó sus primeros juegos en BASIC con MCODER: hablamos de Babaliba, Saimazoom, o la utilidad Artist. MCODER tiene unas limitaciones que no tienen porqué ser especialmente problemáticas si las conocemos, las aceptamos, y realizamos nuestros programas teniéndolas en cuenta. Por ejemplo, no podemos utilizar vectores (creados con DIM en BASIC), y el manejo de cadenas sufre algunos cambios de sintaxis, entre otros.

La principal desventaja de MCODER es que es un compilador BASIC nativo, es decir, que es software para Spectrum que debemos ejecutar dentro de un emulador o la máquina real lo que nos puede ralentizar a la hora de programar.

Una opción mucho más aconsejable es la de utilizar un compilador cruzado como \sphinxstylestrong{ZX Basic Compiler} (ZXB Compiler).

Un \sphinxstylestrong{compilador cruzado} es un compilador que se ejecuta en una plataforma diferente de la plataforma destino, pero genera código para ésta. Por ejemplo, podemos escribir nuestro programa BASIC en un editor de textos en un PC (fuera del Spectrum), compilarlo con un compilador cruzado, y obtener un binario con código máquina de Spectrum, listo para ser ejecutado en un emulador o en una máquina real. De esta forma nos beneficiamos de las mayores capacidades de nuestra plataforma de desarrollo (un PC) para conseguir código compilado para un Spectrum.

En este caso, el compilador cruzado ZX Basic Compiler permite compilar programas escritos en un dialecto BASIC estándar y genera un fichero de instrucciones en ensamblador que podemos ensamblar con ensambladores cruzados.

El ciclo de desarrollo para la compilación de programas BASIC sería similar al siguiente:
\begin{itemize}
\item {} 
Programamos nuestro juego en lenguaje BASIC escribiendo el programa en un editor de textos estándar de nuestra plataforma de desarrollo.

\item {} 
Grabamos el código de nuestro programa como un fichero .BAS.

\item {} 
Mediante el compilador cruzado, compilamos el fichero .BAS y obtenemos un fichero binario de código máquina, normalmente con un cargador BASIC incluído al principio del mismo.

\item {} 
Cargamos ese código máquina en nuestro Spectrum o emulador con un simple LOAD «».

\item {} 
El programa se carga y ejecuta como cualquier otro juego comercial.

\end{itemize}

Es una opción muy interesante para quien quiera seguir programando en BASIC y obtener la potencia que el intérprete de BASIC le resta.


\section{Programando en Lenguaje C}
\label{\detokenize{02_introduccion/introduccion:programando-en-lenguaje-c}}
Otra opción es la de aprender lenguaje C y realizar programas íntegramente en C que son compilados (al igual que hace ZX Basic Compiler) y trasladados a código binario que ejecutará el Spectrum.

Podemos ver el lenguaje C (en el Spectrum) como una manera de realizar programas bastante rápidos saltándonos las limitaciones de BASIC. No llega a ser ensamblador, pero desde luego es mucho más rápido que BASIC (y que BASIC compilado).

C es un lenguaje muy potente y de alto nivel que genera un código bastante óptimo y cuyos binarios tienen una velocidad de ejecución muchísimo más cercana a la de programas en ensamblador que a la de programas BASIC interpretados.

El desarrollo de un juego o programa en C se realizaría de forma similar al caso de los compiladores BASIC:
\begin{itemize}
\item {} 
Programamos nuestro juego en lenguaje C escribiendo el programa en un editor de textos estándar de nuestra plataforma de desarrollo.

\item {} 
Grabamos el código de nuestro programa como un fichero .C .

\item {} 
Mediante el compilador cruzado, compilamos el fichero .C y obtenemos un fichero binario de código máquina, normalmente con un cargador BASIC incluído al principio del mismo.

\item {} 
Cargamos ese código máquina en nuestro Spectrum o emulador con un simple LOAD «».

\item {} 
El programa se carga y ejecuta como cualquier otro juego comercial.

\end{itemize}

Para quien ya conozca el lenguaje C y se desenvuelva bien con él, utilizar un compilador cruzado como pueda serlo Z88DK será sin duda un gran opción. Programando en C se puede hacer prácticamente cualquier aplicación y un gran número de juegos.

Además, se puede embeber código ensamblador dentro de las rutinas en C, con lo cual se puede decir que no estamos limitados por el lenguaje C a la hora de realizar tareas que requieren un control muy preciso de la máquina.


\section{Realizando el programa completo en ensamblador.}
\label{\detokenize{02_introduccion/introduccion:realizando-el-programa-completo-en-ensamblador}}
Finalmente, la última opción: nos hemos decidido y queremos escribir programas directamente en el lenguaje que comprende la máquina, ya que queremos controlar todo lo que realiza el microprocesador.

Con la opción que hemos elegido, escribiremos el código del programa íntegramente en lenguaje ensamblador (assembler language en inglés, o ASM para abreviar).

Con BASIC compilado y con C, es el compilador quien transforma nuestros comandos en código máquina. En el lenguaje ensamblador, la «compilación» (conocida como proceso de ensamblado) del programa en código máquina es una mera traducción ya que cada instrucción en ensamblador se traduce en una instrucción en código máquina, como veremos más adelante.

Para programar en ensamblador seguiremos el siguiente proceso:
\begin{itemize}
\item {} 
Programamos nuestro juego en lenguaje ensamblador escribiendo el programa en un editor de textos estándar de nuestra plataforma de desarrollo.

\item {} 
Grabamos el código de nuestro programa como un fichero .ASM .

\item {} 
Mediante el ensamblador cruzado, ensamblamos el fichero .ASM y obtenemos un fichero binario de código máquina, normalmente con un cargador BASIC incluído al principio del mismo.

\item {} 
Cargamos ese código máquina en nuestro Spectrum o emulador con un simple LOAD «».

\item {} 
El programa se carga y ejecuta como cualquier otro juego comercial.

\end{itemize}

Es importante destacar que el desarrollo de un programa en ASM requiere mucho más tiempo, un mejor diseño y muchos más conocimientos del hardware que utilizar cualquier otro lenguaje. Un programa en BASIC sencillo puede tener 1000 líneas, pero el mismo programa en ASM puede tener perfectamente 10000, 50000, o muchas más líneas.

En ensamblador no tenemos funciones de alto nivel que realicen determinadas tareas por nosotros: no existe PRINT para imprimir cosas por pantalla, si queremos imprimir texto tenemos que imprimir una a una las letras, calculando posiciones, píxeles, colores, y escribiendo en la videomemoria nosotros mismos. Podemos apoyarnos en una serie de rutinas que hay en la ROM del Spectrum (que son las que utiliza BASIC), pero en general, para la mayoría de las tareas, lo tendremos que hacer todo manualmente.

Un ejemplo muy sencillo: en BASIC podemos multiplicar 2 números de forma muy simple con el operador «*». En ensamblador, no existe un comando para multiplicar 2 números. No existe dicho comando porque el micro Z80 tiene definida la operación de suma (ADD) y la de resta (SUB), por ejemplo, pero no tiene ninguna instrucción para multiplicar o dividir. Y si queremos multiplicar 2 números, tendremos que hacer una rutina en ensamblador que lo haga (como la rutina que hemos visto en el apartado anterior) y llamarla cada vez que necesitemos realizar una multiplicación.

Es posible que el anterior párrafo parezca demasiado «duro» para los programadores acostumbrados a BASIC y que lo anteriormente explicado parezca un panorama desolador, pero esa es la realidad con el ensamblador: cada instrucción en ensamblador se corresponde con una instrucción de la CPU Z80. Si se quiere hacer algo más complejo que lo que permite directamente la CPU, nos lo hemos de construir nosotros mismos a base de utilizar esas instrucciones. Una multiplicación se puede realizar como una serie de sumas, por ejemplo, como hemos visto en la rutina MULT del apartado anterior.

Descrito visualmente, en BASIC para construir una casa te dan paredes completas, ventanas, escaleras y puertas, y combinándolos te construyes la casa. En ASM, por contra, lo que te dan es un martillo, clavos, un cincel, madera y roca, y a partir de eso tienes que construir tú todos los elementos del programa.

Obviamente, no tendremos que escribir miles de rutinas antes de poder programar cualquier cosa: existen rutinas ya disponibles que podemos aprovechar. En Internet, en revistas Microhobby, en libros de programación de Z80, en la ROM del Spectrum, encontraremos rutinas listas para utilizar y que nos permitirán multiplicar, dividir, imprimir cadenas de texto, y muchas otras cosas.

Además, cada nueva rutina que programemos podremos reutilizarla en futuros programas, por lo que el inicio es duro pero a partir de cierto momento dispondremos de bibliotecas de rutinas que podremos integrar en nuestros programas para reducir el tiempo de desarrollo.


\section{Por qué aprender ASM (ensamblador) de Z80}
\label{\detokenize{02_introduccion/introduccion:por-que-aprender-asm-ensamblador-de-z80}}
Está claro que cada lenguaje tiene su campo de aplicación, y utilizar BASIC para hacer una herramienta interactiva para el usuario (con mucho tratamiento de textos, o de gráficos) o bien para hacer un programa basado en texto, o una pequeña base de datos o similar puede ser suficiente para muchos casos.

Donde realmente tiene interés la programación en lenguaje ensamblador es en la creación de determinadas rutinas, programas o juegos orientados a exprimir el hardware de la máquina, es decir: aquellos programas orientados a escribir rápidamente gráficos en pantalla, reproducir música, o controlar el teclado con gran precisión. Nos estamos refiriendo principalmente a los juegos.

Ensamblador es el lenguaje ideal para programar juegos que requieran gran velocidad de ejecución. Como veremos en el futuro, dibujar en pantalla se reduce a escribir valores en memoria (en una zona concreta de la memoria). Leer del teclado se reduce a leer los valores que hay en determinados puertos de entrada/salida de la CPU, y la reproducción de música se realiza mediante escrituras en otros puertos. Para realizar esto se requiere mucha sincronización y un control total de la máquina, y esto es lo que nos ofrece ensamblador.

Este curso está diseñado con los siguientes objetivos en mente:
\begin{itemize}
\item {} 
Conocer el hardware del Spectrum, y cómo funciona internamente.

\item {} 
Conocer el juego de instrucciones del microprocesador Z80 que lleva el Spectrum.

\item {} 
Saber realizar programas en lenguaje ASM (ensamblador) del Z80.

\item {} 
Aprender a realizar pequeñas rutinas que hagan tareas determinadas y que sean después reutilizables desde otros programas o desde BASIC.

\item {} 
Con la práctica, ser capaces de escribir un juego o programa entero en ASM.

\end{itemize}

Proporcionaremos al lector todos los conceptos necesarios para conseguir estos objetivos. El resto lo aportará el tiempo que nos impliquemos y la experiencia que vayamos adoptando programando en ensamblador. No se puede escribir un juego completo en ensamblador la primera vez que uno se acerca a este lenguaje, pero sí que puede uno realizar una pequeña rutina que haga una tarea concreta en un pequeño programa BASIC. La segunda vez, en lugar de una pequeña rutina hará un conjunto de rutinas para un juego mayor, y, con la práctica, el dominio del lenguaje se puede convertir para muchos en una manera diferente o mejor de programar: directamente en ensamblador.

Queremos destacar un pequeño detalle: programar en ensamblador no es fácil. Este curso deberían seguirlo aquellas personas con ciertos conocimientos sobre programación que se sientan preparadas para dar el paso al lenguaje ensamblador. Si tienes conocimientos de hardware, sabes cómo funciona un microprocesador, has realizado uno o más programas o juegos en BASIC u otros lenguajes o sabes lo que es binario, decimal y hexadecimal (si sabes cualquiera de esas cosas), entonces no te costará nada seguir este curso. Si, por el contrario, no has programado nunca, y todo lo que hemos hablado no te suena de nada, necesitarás mucha voluntad y consultar muchos otros textos externos (o al menos aplicarte mucho) para poder seguirnos.

Un requerimiento casi imprescindible es que el lector debe de conocer fundamentos básicos del sistema de codificación decimal, hexadecimal y binario. Como ya sabéis, nosotros expresamos los números en base decimal, pero esos mismos números se pueden expresar también en hexadecimal, o en binario. Son diferentes formas de representar el mismo número, y para distinguir unas formas de otras se colocan prefijos o sufijos que nos indican la base utilizada. A lo largo del curso se utilizarán las siguientes convenciones de prefijo de formato:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Prefijo
&\sphinxstyletheadfamily 
Tipo de dato
\\
\hline
\$
&
Valor hexadecimal
\\
\hline
\%
&
Valor en binario
\\
\hline
Ninguno
&
Valor en decimal
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Para seguir el curso es muy importante que el lector sepa distinguir unas bases de codificación de otras y que sepa (con más o menos facilidad) pasar números de una base a otra. Quien no sepa esto lo puede hacer con práctica, conforme va siguiendo el curso.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
DECIMAL
&\sphinxstyletheadfamily 
HEXADECIMAL
&\sphinxstyletheadfamily 
BINARIO
\\
\hline
64d ó 64
&
\$40 ó 40h
&
\%01000000
\\
\hline
255d ó 255
&
\$FF ó FFh
&
\%11111111
\\
\hline
3d ó 3
&
\$03 ó 03h
&
\%00000011
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{El código máquina del microprocesador Z80}
\label{\detokenize{02_introduccion/introduccion:el-codigo-maquina-del-microprocesador-z80}}
El microprocesador Z80 (Z80A en el caso del Spectrum) es un pequeño chip de 40 pines de conexión, cada uno de las cuales está conectada a diferentes señales. Uno de los pines es la alimentación eléctrica, otro la conexión al reloj/cristal de 3.50Mhz, 8 pines suponen el bus de datos y 16 el bus de direcciones, etc.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{z80a}.jpg}
\caption{El microprocesador Z80}\label{\detokenize{02_introduccion/introduccion:id3}}\end{figure}

Estas «patillas» de datos y direcciones están físicamente conectadas a través de pistas eléctricas a la memoria, el teclado, el cassette, etc. Utilizando las patillas de direcciones el procesador selecciona «posiciones de memoria» en la memoria, y recibe las instrucciones de los programas a través de las 8 señales del bus de datos.

Una señal (el estado de cada una de las patillas del micro en un instante concreto) puede tener 2 estados: sin tensión eléctrica (0 Voltios físicos, o señal lógica «0»), o con tensión eléctrica (5 Voltios físicos, o señal lógica «1»). El procesador recibe a través de las 8 patillas del bus de datos 8 señales que conforman una ristra de unos y ceros como puedan serlo 01000100 o 11001100, por ejemplo.

Los diseñadores del Z80 le otorgaron mediante circuitos en su interior una serie de registros de almacenamiento (A, B, C, D, E, F, H, L, etc.) que pueden alojar números, y la capacidad de ejecutar una serie de instrucciones (sumar, restar, comparar, etc.) entre ellos (y también entre ellos y otras posiciones de memoria).

Cada posible conjunto de señales entre 00000000 y 11111111 se corresponde con una de estas posibles operaciones mediante un «diccionario interno» que le dice al Z80 qué debe de hacer según la instrucción que se le está solicitando.

Cuando el microprocesador obtiene de la memoria la siguiente instrucción del programa a ejecutar y obtiene, por ejemplo, un conjunto de señales «01010000», el Z80 sabe que tiene que sumar el contenido de su registro interno A con el del registro interno B, y dejar el resultado en A.

Es decir, entiende un número binario de 8 digítos que recibe en forma de señales binarias como una instrucción concreta a ejecutar. Este valor numérico es lo que se conoce como un \sphinxstylestrong{«Opcode»} o \sphinxstylestrong{«código de operación»}, ya que un código (01010000) le indica al procesador qué operación ejecutar (A = A + B).

Un programa en código máquina no es más que una ristra de código binarios de 8 dígitos (de instrucciones) que le indican al Z80 qué operaciones ejecutar en un orden concreto. El procesador leerá una a una la ristra de códigos binarios que forman el programa y ejecutará cada una de las instrucciones con que se corresponde cada código.

El Z80 utiliza un registro interno especial llamado PC (Program Counter o Contador de Programa) para saber cuál es la dirección de la instrucción actual con la que está trabajando y lo incrementa tras cada instrucción para poder seguir el flujo del programa.

Cuando arrancamos nuestro Spectrum, todos los registros del Z80 (A, B, C, PC, etc) valen 0, por lo que el Spectrum empieza a leer desde la memoria en la posición 0, instrucción tras instrucción, incrementando el valor de PC tras ejecutar cada una de ellas. Este programa «inicial» que ejecuta nuestro Spectrum es nada más y nada menos que el intérprete de BASIC, escrito para Sinclair por ingenierios de Nine Tiles Information Handlind Ltd.

Este código máquina con todo el programa que supone el intérprete BASIC está almacenado como ristra de instrucciones en un chip del Spectrum llamado ROM cuyo contenido no se borra al apagar el ordenador.

Programar en código máquina no es fácil, puesto que no es inmediata la correspondencia entre una ristra de unos y ceros y la instrucción que ejecutará el procesador. Una vez escrito un programa, es también muy complicado de depurar en busca de errores, puesto que todo lo que tenemos son miles o decenas de miles de ristras de 8 dígitos binarios.

Veamos algunas instrucciones en código máquina y el efecto que tienen en el procesador cuando le pedimos ejecutarlas:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Instrucción en hexadecimal
&\sphinxstyletheadfamily 
Señales en bus de datos (binario)
&\sphinxstyletheadfamily 
Instrucción ejecutada
\\
\hline
\$09
&
00001001
&
HL = HL + BC
\\
\hline
\$50
&
01010000
&
A = A + B
\\
\hline
\$3C
&
00111100
&
Incrementar A ; A = A + 1
\\
\hline
\$3D
&
00111101
&
Decrementar A ; A = A \sphinxhyphen{} 1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}

El conjunto completo de operaciones que puede realizar el procesador representado por los opcodes asociados a los mismos se conoce como \sphinxstylestrong{juego de instrucciones del procesador}.
\end{quote}

Recordar todos los códigos de operación del juego de instrucciones es muy complejo y la programación en base a utilizar ristras de números es prácticamente inmanejable. Debido a esta complejidad y dificultad, nunca se programa directamente en código máquina sino que se realiza en \sphinxstylestrong{lenguaje ensamblador}.


\section{El lenguaje ensamblador}
\label{\detokenize{02_introduccion/introduccion:el-lenguaje-ensamblador}}
El lenguaje ensamblador es una «versión humana» del lenguaje máquina en la que asociamos un «nombre» (técnicamente conocido como mnenónico) a cada instrucción de 8 bits del procesador.

Así, en lugar de definir la suma de A = A + B como \sphinxstylestrong{«001010000»}, la definimos como \sphinxstylestrong{«ADD A, B»}, lo cual es mucho más legible e intuitivo a la hora de programar y depurar y sigue siendo igual de compacto, existiendo una correspondencia exacta de 1 instrucción ASM = 1 instrucción en código máquina.

De esta forma, podemos programar utilizando un conjunto de instrucciones en lenguaje «humano», que no llegan a ser tan especializadas y de tanto alto nivel como en BASIC ya que el objetivo del lenguaje ensamblador es dotar de un nombre «legible» a cada microinstrucción disponible en el procesador.

Al programar en lenguaje ensamblador, lo hacemos pues en este lenguaje humano con instrucciones como «ADD A, B», «LD A, 20» o «CALL subrutina». El problema es que el microprocesador no entiende este lenguaje humano, ya que él sólo entiende las señales de 8 dígitos binarios que lee de la memoria.

Para solucionar esto se necesita un programa llamado \sphinxstylestrong{«programa ensamblador»} o simplemente \sphinxstylestrong{ensamblador} o \sphinxstylestrong{assembler}, que lee nuestros programas en lenguaje ensamblador y convierte cada instrucción en ensamblador en la correspondiente instrucción código máquina. El resultado de la conversión de cada instrucción se va almacenando de forma consecutiva para acabar obteniendo un bloque de datos que contiene la traducción a código máquina de todo el programa que hemos solicitado ensamblar.

Para realizar este proceso, el programa ensamblador se vale de una tabla de ensamblado que relaciona cada instrucción en ensamblador con la instrucción en código máquina que realiza la misma acción. Así, cuando lee en nuestro programa «ADD A, B», lo traduce por un «001010000» que es lo que realmente almacena en el programa en código máquina resultante.

En resumen: como resultado de un proceso de ensamblado, el ensamblador convierte un programa en este «lenguaje ensamblador» a una ristra de dígitos binarios en memoria que se corresponden, en código máquina, con las instrucciones que nosotros hemos solicitado realizar al procesador en ensamblador.

Una vez el programa está totalmente acabado (asumiendo que no tenga fallos y no sea necesario depurarlo) sólo es necesario realizar una vez el proceso de ensamblado. Por ejemplo, los programadores de un juego ensamblarán el listado del mismo, obtendrán una ristra de dígitos binarios en memoria, y la salvarán en cinta. Lo que se distribuye a los usuarios es el programa en código máquina que el Spectrum cargará en memoria y ejecutará.

El proceso de ensamblado puede ser manual: nosotros podemos utilizar una tabla de traducción instrucciones \(\rightarrow\) opcodes y traducir manualmente cada instrucción en el opcode correspondiente. No obstante, lo más normal es utilizar un programa ensamblador, que automatiza este proceso por nosotros.

En este curso, programaremos nuestras rutinas o programas en lenguaje ensamblador en un fichero de texto con extensión .asm, y con un programa ensamblador cruzado lo traduciremos al código binario que entiende la CPU del Spectrum. Ese código binario puede ser ejecutado, instrucción a instrucción, por el Z80, realizando las tareas que nosotros le encomendemos en nuestro programa.

En este capítulo no vamos a ver la sintaxis e instrucciones disponibles en el ensamblador del microprocesador Z80: eso será algo que haremos capítulo a capítulo del curso. Por ahora nos debe bastar conocer que el lenguaje ensamblador es mucho más limitado en cuanto a instrucciones que BASIC, y que, a base de pequeñas piezas, debemos montar nuestro programa entero, que será sin duda mucho más rápido en cuanto a ejecución.

Como las piezas de construcción son tan pequeñas, para hacer tareas que son muy sencillas en BASIC, en ensamblador necesitaremos muchas líneas de programa, es por eso que los programas en ensamblador en general requieren más tiempo de desarrollo y se vuelven más complicados de mantener (de realizar cambios, modificaciones) y de leer conforme crecen. Debido a esto cobra especial importancia hacer un diseño en papel de los bloques del programa (y seguirlo) antes de programar una sóla línea del mismo. También se hacen especialmente importantes los comentarios que introduzcamos en nuestro código, ya que clarificarán su lectura en el futuro. El diseño es CLAVE y VITAL a la hora de programar: sólo se debe implementar lo que está diseñado previamente, y cualquier modificación de las especificaciones debe resultar en una modificación del diseño.

Así pues, resumiendo, lo que haremos a lo largo de este curso será aprender la arquitectura interna del Spectrum, su funcionamiento a nivel de CPU, y los fundamentos de su lenguaje ensamblador, con el objetivo de programar rutinas que integraremos en nuestros programas BASIC, o bien programas completos en ensamblador que serán totalmente independientes del lenguaje BASIC.


\section{Ejemplo: Integrar código máquina en programas BASIC}
\label{\detokenize{02_introduccion/introduccion:ejemplo-integrar-codigo-maquina-en-programas-basic}}
Supongamos que sabemos ensamblador y queremos mejorar la velocidad de un programa BASIC utilizando una rutina en código máquina. El lector se preguntará: «¿cómo podemos hacer esto?».

La integración de rutinas en código máquina dentro de programas BASIC se realiza a grandes rasgos de la siguiente forma:

Primero escribimos nuestra rutina en ensamblador, por ejemplo una rutina que realiza un borrado de la pantalla mucho más rápidamente que realizarlo en BASIC, o una rutina de impresión de Sprites o gráficos, etc.

Una vez escrito el programa o la rutina, la ensamblamos (de la manera que sea: manualmente o mediante un programa ensamblador) y obtenemos en lugar del código ASM una serie de valores numéricos que representan los códigos de instrucción en código máquina que se corresponden con nuestro listado ASM.

La siguiente figura muestra a título de ejemplo parte de una tabla de ensamblado manual, como la que utilizaban en la década de los 80 y 90 los programadores que no podían comprar un software ensamblador:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{tablamanual}.png}
\caption{Tabla de códigos ensamblador}\label{\detokenize{02_introduccion/introduccion:id4}}\end{figure}

Utilizando la anterior tabla, o bien un programa ensamblador, transformamos nuestro programa ensamblador en código máquina.

Tras el proceso de ensamblado y la obtención del código máquina, nuestro programa en BASIC debe cargar esos valores en memoria (mediante LOAD «» CODE o mediante instrucciones POKE) y después saltar a la dirección donde hemos POKEADO la rutina para ejecutarla.

Veamos un ejemplo de todo esto. Supongamos el siguiente programa en BASIC, que está pensado para rellenar toda la pantalla con un patrón de píxeles determinado:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nl}{10}\PYG{+w}{ }\PYG{k+kr}{FOR}\PYG{+w}{ }\PYG{n+nv+vg}{n}\PYG{o}{=}\PYG{l+m+mi+il}{16384}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{l+m+mi+il}{23295}
\PYG{n+nl}{20}\PYG{+w}{ }\PYG{k+kr}{POKE}\PYG{+w}{ }\PYG{n+nv+vg}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{162}
\PYG{n+nl}{30}\PYG{+w}{ }\PYG{k+kr}{NEXT}\PYG{+w}{ }\PYG{n+nv+vg}{n}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{1_ejemplo1}.png}
\caption{Patrón de pixeles del programa BASIC}\label{\detokenize{02_introduccion/introduccion:id5}}\end{figure}

Tras teclear y ejecutar el programa, si medimos el tiempo necesario para «pintar» toda la pantalla obtendremos que tarda aproximadamente 1 minuto y 15 segundos.

A continuación vamos a ver el mismo programa escrito en lenguaje ensamblador:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{c+c1}{; Listado 2: Rellenado de pantalla}
   \PYG{k}{ORG} \PYG{l+m+mi}{40000}
   \PYG{n+nf}{LD} \PYG{n+nv}{HL}\PYG{p}{,} \PYG{l+m+mi}{16384}
   \PYG{n+nf}{LD} \PYG{n+nv}{A}\PYG{p}{,} \PYG{l+m+mi}{162}
   \PYG{n+nf}{LD} \PYG{p}{(}\PYG{n+nv}{HL}\PYG{p}{),} \PYG{n+nv}{A}
   \PYG{n+nf}{LD} \PYG{n+nv}{DE}\PYG{p}{,} \PYG{l+m+mi}{16385}
   \PYG{n+nf}{LD} \PYG{n+nv}{BC}\PYG{p}{,} \PYG{l+m+mi}{6911}
   \PYG{n+nf}{LDIR}
   \PYG{n+nf}{RET}

\PYG{n+nf}{Si} \PYG{n+nv}{ensamblamos} \PYG{n+nb}{es}\PYG{n+nv}{te} \PYG{n+nv}{programa} \PYG{n+nv}{con} \PYG{n+nv}{un} \PYG{n+nv}{programa} \PYG{n+nv}{ensamblador} \PYG{n+nv}{y} \PYG{n+nv}{lo} \PYG{n+nv}{ejecutamos}\PYG{p}{,} \PYG{n+nv}{veremos} \PYG{n+nv}{que} \PYG{n+nv}{tarda} \PYG{n+nv}{menos} \PYG{n+nv}{de} \PYG{l+m+mi}{1} \PYG{o+ow}{seg}\PYG{n+nv}{undo} \PYG{n+nv}{en} \PYG{n+nv}{ejecutar} \PYG{n+nv}{la} \PYG{n+nv}{misma} \PYG{n+nv}{tarea.} \PYG{n+nb}{Es} \PYG{n+nv}{en} \PYG{n+nv}{ejemplos} \PYG{n+nv}{tan} \PYG{n+nv}{sencillos} \PYG{n+nv}{como} \PYG{n+nb}{es}\PYG{n+nv}{te} \PYG{n+nv}{donde} \PYG{n+nv}{podemos} \PYG{n+nv}{ver} \PYG{n+nv}{la} \PYG{n+nb}{di}\PYG{n+nv}{ferencia} \PYG{n+nv}{de} \PYG{n+nv}{velocidad} \PYG{n+nv}{entre} \PYG{n+nv}{BASIC} \PYG{n+nv}{y} \PYG{n+nv}{ASM.}
\end{sphinxVerbatim}

Supongamos que ensamblamos a mano el listado anterior, mediante una tabla de conversión de Instrucciones ASM a Códigos de Operación (opcodes) del Z80, ensamblando manualmente (tenemos una tabla de conversión en el mismo manual del +2, por ejemplo).

Ensamblar a mano, como ya hemos dicho, consiste en escribir el programa y después traducirlo a códigos de operación consultando una tabla que nos dé el código correspondiente a cada instrucción en ensamblador.

Así pues, ensamblamos manualmente la siguiente rutina:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{LD} \PYG{n+nv}{HL}\PYG{p}{,} \PYG{l+m+mi}{16384}
\PYG{n+nf}{LD} \PYG{n+nv}{A}\PYG{p}{,} \PYG{l+m+mi}{162}
\PYG{n+nf}{LD} \PYG{p}{(}\PYG{n+nv}{HL}\PYG{p}{),} \PYG{n+nv}{A}
\PYG{n+nf}{LD} \PYG{n+nv}{DE}\PYG{p}{,} \PYG{l+m+mi}{16385}
\PYG{n+nf}{LD} \PYG{n+nv}{BC}\PYG{p}{,} \PYG{l+m+mi}{6911}
\PYG{n+nf}{LDIR}
\PYG{n+nf}{RET}
\end{sphinxVerbatim}

Tras el ensamblado del código ensamblador obtendremos el siguiente código máquina (una rutina de 15 bytes de tamaño): \sphinxcode{\sphinxupquote{\$21, \$00, \$40, \$3e, \$a2, \$77, \$11, \$01, \$40, \$01, \$ff, \$1a, \$ed, \$b0, \$c9}} O, en base decimal: \sphinxcode{\sphinxupquote{33, 0, 64, 62, 162, 119, 17, 1, 64, 1, 255, 26, 237, 176, 201}}
\begin{quote}

Como ya hemos visto en la definición de «código máquina», esta extraña ristra de bytes para nosotros incomprensible tiene un total significado para nuestro Spectrum: cuando él encuentra, por ejemplo, los bytes «62, 162», sabe que eso quiere decir «LD A, 162»; cuando encuentra el byte «201», sabe que tiene que ejecutar un «RET», y así con todas las demás instrucciones.
\end{quote}

Un detalle: si no queremos ensamblar a mano podemos ensamblar el programa con un ensamblador como «PASMO» o «z80asm» y después obtener esos números abriendo el fichero .bin resultando con un editor hexadecimal (que no de texto).

A continuación vamos a BASIC y tecleamos el siguiente programa:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{   }\PYG{l+m+mi+il}{10}\PYG{+w}{ }\PYG{k+kr}{CLEAR}\PYG{+w}{ }\PYG{l+m+mi+il}{39999}
\PYG{+w}{   }\PYG{l+m+mi+il}{20}\PYG{+w}{ }\PYG{k+kd}{DATA}\PYG{+w}{ }\PYG{l+m+mi+il}{33}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{64}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{62}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{162}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{119}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{17}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{64}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{255}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{26}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{237}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{176}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{201}
\PYG{+w}{   }\PYG{l+m+mi+il}{30}\PYG{+w}{ }\PYG{k+kr}{FOR}\PYG{+w}{ }\PYG{n+nv+vg}{n}\PYG{o}{=}\PYG{l+m+mi+il}{0}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{l+m+mi+il}{14}
\PYG{+w}{   }\PYG{l+m+mi+il}{40}\PYG{+w}{ }\PYG{k+kr}{READ}\PYG{+w}{ }\PYG{n+nv+vg}{I}
\PYG{+w}{   }\PYG{l+m+mi+il}{50}\PYG{+w}{ }\PYG{k+kr}{POKE}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi+il}{40000}\PYG{o}{+}\PYG{n+nv+vg}{n}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv+vg}{I}
\PYG{+w}{   }\PYG{l+m+mi+il}{60}\PYG{+w}{ }\PYG{k+kr}{NEXT}\PYG{+w}{ }\PYG{n+nv+vg}{n}

\PYG{n+nv+vg}{Este}\PYG{+w}{ }\PYG{n+nv+vg}{programa}\PYG{+w}{ }\PYG{n+nv+vg}{guarda}\PYG{+w}{ }\PYG{n+nv+vg}{a}\PYG{+w}{ }\PYG{n+nv+vg}{partir}\PYG{+w}{ }\PYG{n+nv+vg}{de}\PYG{+w}{ }\PYG{n+nv+vg}{la}\PYG{+w}{ }\PYG{n+nv+vg}{dirección}\PYG{+w}{ }\PYG{l+m+mi+il}{40000}\PYG{+w}{ }\PYG{n+nv+vg}{los}\PYG{+w}{ }\PYG{n+nv+vg}{diferentes}\PYG{+w}{ }\PYG{n+nv+vg}{bytes}\PYG{+w}{ }\PYG{n+nv+vg}{del}\PYG{+w}{ }\PYG{k+kd}{DATA}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nv+vg}{usando}\PYG{+w}{ }\PYG{k+kr}{POKE}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv+vg}{almacenando}\PYG{+w}{ }\PYG{n+nv+vg}{así}\PYG{+w}{ }\PYG{n+nv+vg}{nuestra}\PYG{+w}{ }\PYG{n+nv+vg}{rutina}\PYG{+w}{ }\PYG{n+nv+vg}{en}\PYG{+w}{ }\PYG{n+nv+vg}{memoria}\PYG{o}{.}
\end{sphinxVerbatim}

Tras esto ejecutamos un RANDOMIZE USR 40000 lo que provoca la ejecución de la rutina posicionada en la dirección 40000, que justo es la rutina que hemos ensamblado a mano y pokeado mediante el programa en BASIC.

Lo que hemos hecho en el programa BASIC es:
\begin{itemize}
\item {} 
Con el CLEAR nos aseguramos de que tenemos libre la memoria desde 40000 hacia arriba (hacemos que BASIC se situe por debajo de esa memoria).

\item {} 
La línea DATA contiene el código máquina de nuestra rutina.

\item {} 
Con el bucle FOR hemos POKEado la rutina en memoria a partir de la dirección 40000 (desde 40000 a 40015).

\item {} 
El RANDOMIZE USR 40000 salta la ejecución del Z80 a la dirección 40000, donde está nuestra rutina. Recordad que nuestra rutina acaba con un RET, que es una instrucción de retorno que finaliza la rutina y realiza una «vuelta» al BASIC.

\end{itemize}
\begin{quote}

Siguiendo este mismo procedimiento podemos generar todas las rutinas que necesitemos y ensamblarlas, obteniendo ristras de código máquina que meteremos en DATAs y pokearemos en memoria.
\end{quote}

Otra opción, para evitar los DATAs y los POKEs, es grabar en cinta el fichero BIN resultante del ensamblado (convertido a TAP) tras nuestro programa en BASIC, y realizar en nuestro programa un \sphinxstylestrong{LOAD «» CODE DIRECCION\_DESTINO} de forma que carguemos todo el código binario ensamblado en memoria.

Podemos así realizar muchas rutinas en un mismo fichero ASM y ensamblarlas y cargarlas en memoria de una sola vez. Tras tenerlas en memoria, tan sólo necesitaremos saber la dirección de inicio de cada una de las rutinas para llamarlas con el \sphinxstylestrong{RANDOMIZE USR DIRECCION\_RUTINA} correspondiente en cualquier momento de nuestro programa BASIC.

Para hacer esto, ese fichero ASM podría tener una forma como la siguiente:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; La rutina 1}
\PYG{k}{ORG} \PYG{l+m+mi}{40000}
\PYG{n+nl}{rutina1:}
\PYG{c+c1}{; Aquí la rutina 1}
\PYG{n+nf}{RET}

\PYG{c+c1}{; La rutina 2}
\PYG{k}{ORG} \PYG{l+m+mi}{41000}
\PYG{n+nl}{rutina2:}
\PYG{c+c1}{; Aquí la rutina 2}
\PYG{n+nf}{RET}
\end{sphinxVerbatim}

También podemos ensamblarlas por separado y después cargarlas con varios LOAD «» CODE.

Hay que tener mucho cuidado a la hora de teclear los DATAs (y de ensamblar) si lo hacemos a mano, porque equivocarnos en un sólo número cambiaría totalmente el significado del programa y no haría lo que debería haber hecho el programa correctamente pokeado en memoria.

Un detalle más avanzado sobre ejecutar rutinas desde BASIC es el hecho de que podamos necesitar pasar parámetros a una rutina, o recibir un valor de retorno desde una rutina.

Pasar parámetros a una rutina significa indicarle a la rutina uno o más valores para que haga algo con ellos. Por ejemplo, si tenemos una rutina que borra la pantalla con un determinado patrón o color, podría ser interesante poder pasarle a la rutina el valor a escribir en memoria (el patrón). Esto se puede hacer de muchas formas: la más sencilla sería utilizar una posición libre de memoria para escribir el patrón, y que la rutina lea de ella. Por ejemplo, si cargamos nuestro código máquina en la dirección 40000 y consecutivas, podemos por ejemplo usar la dirección 50000 para escribir uno (o más) parámetros para las rutinas. Un ejemplo:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; Listado 3: Rellenado de pantalla}
\PYG{c+c1}{; recibiendo el patron como parametro.}
\PYG{k}{ORG} \PYG{l+m+mi}{40000}

\PYG{c+c1}{; En vez de 162, ponemos en A lo que hay en la}
\PYG{c+c1}{; dirección de memoria 50000}
\PYG{n+nf}{LD} \PYG{n+nv}{A}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{50000}\PYG{p}{)}

\PYG{c+c1}{; El resto del programa es igual:}
\PYG{n+nf}{LD} \PYG{n+nv}{HL}\PYG{p}{,} \PYG{l+m+mi}{16384}
\PYG{n+nf}{LD} \PYG{p}{(}\PYG{n+nv}{HL}\PYG{p}{),} \PYG{n+nv}{A}
\PYG{n+nf}{LD} \PYG{n+nv}{DE}\PYG{p}{,} \PYG{l+m+mi}{16385}
\PYG{n+nf}{LD} \PYG{n+nv}{BC}\PYG{p}{,} \PYG{l+m+mi}{6911}
\PYG{n+nf}{LDIR}
\PYG{n+nf}{RET}
\end{sphinxVerbatim}

Nuestro programa en BASIC a la hora de llamar a esta rutina (una vez ensamblada y pokeada en memoria) haría:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{   }\PYG{k+kr}{POKE}\PYG{+w}{ }\PYG{l+m+mi+il}{50000}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{162}
\PYG{+w}{   }\PYG{k+kr}{RANDOMIZE}\PYG{+w}{ }\PYG{n+nv+vg}{USR}\PYG{+w}{ }\PYG{l+m+mi+il}{40000}

\PYG{n+nv+vg}{Este}\PYG{+w}{ }\PYG{n+nv+vg}{código}\PYG{+w}{ }\PYG{n+nv+vg}{produciría}\PYG{+w}{ }\PYG{n+nv+vg}{la}\PYG{+w}{ }\PYG{n+nv+vg}{misma}\PYG{+w}{ }\PYG{n+nv+vg}{ejecución}\PYG{+w}{ }\PYG{n+nv+vg}{que}\PYG{+w}{ }\PYG{n+nv+vg}{el}\PYG{+w}{ }\PYG{n+nv+vg}{ejemplo}\PYG{+w}{ }\PYG{n+nv+vg}{anterior}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv+vg}{porque}\PYG{+w}{ }\PYG{n+nv+vg}{como}\PYG{+w}{ }\PYG{n+nv+vg}{parámetro}\PYG{+w}{ }\PYG{n+nv+vg}{estamos}\PYG{+w}{ }\PYG{n+nv+vg}{pasando}\PYG{+w}{ }\PYG{n+nv+vg}{el}\PYG{+w}{ }\PYG{n+nv+vg}{valor}\PYG{+w}{ }\PYG{l+m+mi+il}{162}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv+vg}{pero}\PYG{+w}{ }\PYG{n+nv+vg}{podríamos}\PYG{+w}{ }\PYG{n+nv+vg}{llamar}\PYG{+w}{ }\PYG{n+nv+vg}{de}\PYG{+w}{ }\PYG{n+nv+vg}{nuevo}\PYG{+w}{ }\PYG{n+nv+vg}{a}\PYG{+w}{ }\PYG{n+nv+vg}{la}\PYG{+w}{ }\PYG{n+nv+vg}{misma}\PYG{+w}{ }\PYG{n+nv+vg}{función}\PYG{+w}{ }\PYG{n+nv+vg}{en}\PYG{+w}{ }\PYG{n+nv+vg}{cualquier}\PYG{+w}{ }\PYG{n+nv+vg}{otro}\PYG{+w}{ }\PYG{n+nv+vg}{punto}\PYG{+w}{ }\PYG{n+nv+vg}{de}\PYG{+w}{ }\PYG{n+nv+vg}{nuestro}\PYG{+w}{ }\PYG{n+nv+vg}{programa}\PYG{+w}{ }\PYG{n+nv+vg}{pasando}\PYG{+w}{ }\PYG{n+nv+vg}{otro}\PYG{+w}{ }\PYG{n+nv+vg}{parámetro}\PYG{+w}{ }\PYG{n+nv+vg}{diferente}\PYG{+w}{ }\PYG{n+nv+vg}{a}\PYG{+w}{ }\PYG{n+nv+vg}{la}\PYG{+w}{ }\PYG{n+nv+vg}{misma}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv+vg}{cambiando}\PYG{+w}{ }\PYG{n+nv+vg}{el}\PYG{+w}{ }\PYG{n+nv+vg}{valor}\PYG{+w}{ }\PYG{n+nv+vg}{de}\PYG{+w}{ }\PYG{n+nv+vg}{la}\PYG{+w}{ }\PYG{n+nv+vg}{dirección}\PYG{+w}{ }\PYG{l+m+mi+il}{50000}\PYG{+w}{ }\PYG{n+nv+vg}{de}\PYG{+w}{ }\PYG{n+nv+vg}{la}\PYG{+w}{ }\PYG{n+nv+vg}{memoria}\PYG{o}{.}\PYG{+w}{ }\PYG{n+nv+vg}{Esto}\PYG{+w}{ }\PYG{n+nv+vg}{rellenaría}\PYG{+w}{ }\PYG{n+nv+vg}{la}\PYG{+w}{ }\PYG{n+nv+vg}{pantalla}\PYG{+w}{ }\PYG{n+nv+vg}{con}\PYG{+w}{ }\PYG{n+nv+vg}{un}\PYG{+w}{ }\PYG{n+nv+vg}{patrón}\PYG{+w}{ }\PYG{n+nv+vg}{que}\PYG{+w}{ }\PYG{n+nv+vg}{deseemos}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv+vg}{pudiendo}\PYG{+w}{ }\PYG{n+nv+vg}{ser}\PYG{+w}{ }\PYG{n+nv+vg}{éste}\PYG{+w}{ }\PYG{n+nv+vg}{diferente}\PYG{+w}{ }\PYG{n+nv+vg}{del}\PYG{+w}{ }\PYG{n+nv+vg}{utilizado}\PYG{+w}{ }\PYG{n+nv+vg}{en}\PYG{+w}{ }\PYG{n+nv+vg}{el}\PYG{+w}{ }\PYG{n+nv+vg}{anterior}\PYG{+w}{ }\PYG{n+nv+vg}{ejemplo}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nv+vg}{simplemente}\PYG{+w}{ }\PYG{n+nv+vg}{variando}\PYG{+w}{ }\PYG{n+nv+vg}{el}\PYG{+w}{ }\PYG{n+nv+vg}{valor}\PYG{+w}{ }\PYG{n+nv+vg}{pokeado}\PYG{+w}{ }\PYG{n+nv+vg}{en}\PYG{+w}{ }\PYG{n+nv+vg}{la}\PYG{+w}{ }\PYG{n+nv+vg}{dirección}\PYG{+w}{ }\PYG{l+m+mi+il}{50000}\PYG{+w}{ }\PYG{p}{(}\PYG{n+nv+vg}{el}\PYG{+w}{ }\PYG{n+nv+vg}{parámetro}\PYG{+w}{ }\PYG{n+nv+vg}{de}\PYG{+w}{ }\PYG{n+nv+vg}{la}\PYG{+w}{ }\PYG{n+nv+vg}{rutina}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

En el caso de necesitar más de un parámetro, podemos usar direcciones consecutivas de memoria: en una rutina de dibujado de sprites, podemos pasar la X en la dirección 50000, la Y en la 50001, y en la 50002 y 50003 la dirección en memoria (2 bytes porque las direcciones de memoria son de 16 bits) donde tenemos el Sprite a dibujar, por ejemplo. Todo eso lo veremos con más detalle en posteriores capítulos. En este ejemplo hemos utilizado la dirección 50000, pero lo normal es utilizar direcciones concretas y reservadas dentro del propio programa ensamblado para asegurar que no hay colisión con otras rutinas que pueda haber o podamos necesitar instalar en la dirección 50000.

Además de recibir parámetros, puede sernos interesante la posibilidad de devolver a BASIC el resultado de la ejecución de nuestro programa. Por ejemplo, supongamos que realizamos una rutina en ensamblador que hace un determinado cálculo y debe devolver, tras todo el proceso, un valor. Ese valor lo queremos asignar a una variable de nuestro programa BASIC para continuar trabajando con él.

Un ejemplo: imaginemos que realizamos una rutina que calcula el factorial de un número de una manera mucho más rapida que su equivalente en BASIC. Para devolver el valor a BASIC en nuestra rutina ASM, una vez realizados los cálculos, debemos dejarlo dentro del registro BC justo antes de hacer el RET. Una vez programada la rutina y pokeada, la llamamos mediante:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{LET}\PYG{+w}{ }\PYG{n+nv+vg}{VALOR}\PYG{o}{=}\PYG{n+nv+vg}{USR}\PYG{+w}{ }\PYG{l+m+mi+il}{40000}
\end{sphinxVerbatim}

Con esto la variable de BASIC VALOR contendrá la salida de nuestra rutina (concretamente, el valor del registro BC antes de ejecutar el RET). Las rutinas sólo pueden devolver un valor (el registro BC), aunque siempre podemos (dentro de nuestra rutina BASIC) escribir valores en direcciones de memoria y leerlos después con PEEK dentro de BASIC (al igual que hacemos para pasar parámetros).


\section{Código máquina en MICROHOBBY}
\label{\detokenize{02_introduccion/introduccion:codigo-maquina-en-microhobby}}
Lo que hemos visto hasta ahora es que podemos programar pequeñas rutinas y llamarlas desde programas en BASIC fácilmente. Todavía no hemos aprendido nada del lenguaje en sí mismo, pero se han asentado muchos de los conceptos necesarios para entenderlo en las próximas entregas del curso.

En realidad, muchos de nosotros hemos introducido código máquina en nuestros Spectrums sin saberlo, cuando tecleabamos los listados de programa que venían en la fabulosa revista Microhobby. Muchos de los programas nos hacían introducir código máquina, aunque no lo pareciera.

Algunas veces lo hacíamos en forma de DATAs, integrados en el programa BASIC que estábamos tecleando, pero otras lo hacíamos mediante el famoso Cargador Universal de Código Máquina (CUCM).

Para que os hagáis una idea de qué era el CUCM de Microhobby, no era más que un programa en el cual tecleabamos los códigos binarios de rutinas ASM ensambladas previamente. Se tecleaba una larga línea de números en hexadecimal agrupados juntos (ver la siguiente figura), y cada 10 bytes o pares de dígitos se debía introducir un número a modo de CRC que aseguraba que los 10 dígitos (20 caracteres) anteriores habían sido introducidos correctamente. Este CRC podía no ser más que la suma de todos los valores anteriores, para asegurarse de que no habíamos tecleado incorrectamente el listado.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{cucm}.jpg}
\caption{Un listado para el cargador universal de código máquina}\label{\detokenize{02_introduccion/introduccion:id6}}\end{figure}

Al acabar la introducción en todo el listado en el CUCM, se nos daba la opción de grabarlo. Al grabarlo indicábamos el tamaño de la rutina en bytes y la dirección donde la ibamos a alojar en memoria (en el ejemplo de la captura, la rutina se alojaría en la dirección 53000 y tenía 115 bytes de tamaño). El CUCM todo lo que hacía era un simple:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv+vg}{SAVE}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}DATOS.BIN\PYGZdq{}}\PYG{+w}{ }\PYG{n+nv+vg}{CODE}\PYG{+w}{ }\PYG{l+m+mi+il}{53000}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{115}
\end{sphinxVerbatim}

Esto grababa el bloque de código máquina en cinta (justo tras nuestro programa en BASIC), de forma que el juego en algún momento cargaba esta rutina con LOAD «» CODE, y podía utilizarla mediante un RANDOMIZE USR 53000.


\section{PASMO: ensamblador cruzado}
\label{\detokenize{02_introduccion/introduccion:pasmo-ensamblador-cruzado}}
El lector se preguntará: «Ensamblar programas a mano es muy costoso y complejo, ¿cómo vamos a ensamblar los listados que veamos a lo largo del curso, o los que yo realice para ir practicando o para que sean mis propias rutinas o programas?».

Sencillo: lo haremos con pasmo, un programa ensamblador cruzado. Pasmo nos permitirá programar en un PC o MAC (utilizando nuestro editor de textos habitual), y después ensamblar ese fichero .asm que hemos realizado, obteniendo un fichero .BIN (o directamente un .TAP).

Los programadores «originales» en la época del Spectrum tenían que utilizar programas ensamblador nativos como MONS y GENS para todo el proceso de desarrollo. Estos programas (que corren sobre el Spectrum) implicaban teclear los programas en el teclado del Spectrum, grabarlos en cinta, ensamblar y grabar el resultado en cinta, etc. Actualmente es mucho más cómodo usar ensambladores cruzados como los que usaremos en nuestro curso.

Nuestra opción preferente como ensamblador cruzado es Pasmo. Pasmo es un ensamblador cruzado, opensource y multiplataforma. Con Pasmo podremos programar en nuestro PC, grabar un fichero ASM y ensamblarlo cómodamente, sin cintas de por medio. Tras todo el proceso de desarrollo, podremos llevar el programa resultante a una cinta (o disco) y ejecutarlo por lo tanto en un Spectrum real, pero lo que es el proceso de desarrollo se realiza en un PC, con toda la comodidad que eso conlleva.

Pasmo en su versión para Windows/DOS es un simple ejecutable (pasmo.exe) acompañado de ficheros README de información. Podemos mover el fichero pasmo.exe a cualquier directorio que esté en el PATH o directamente ensamblar programas (siempre desde la línea de comandos o CMD, no directamente mediante «doble click» al ejecutable) en el directorio en el que lo tengamos copiado.

La versión para Linux viene en formato código fuente (y se compila con un simple make) y su binario «pasmo» lo podemos copiar, por ejemplo, en /usr/local/bin.


\section{Generando código binario para programas BASIC}
\label{\detokenize{02_introduccion/introduccion:generando-codigo-binario-para-programas-basic}}
Iremos viendo el uso de pasmo conforme lo vayamos utilizando, pero a título de ejemplo, veamos cómo se ensamblaría el programa que vimos en el apartado de integración de BASIC y ASM. Primero tecleamos el programa en un fichero de texto y después pasmo para ensamblarlo:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{pasmo} \PYG{n}{ejemplo1}\PYG{o}{.}\PYG{n}{asm} \PYG{n}{ejemplo1}\PYG{o}{.}\PYG{n}{bin}

\PYG{n}{Como} \PYG{n}{resultado} \PYG{k}{del} \PYG{n}{proceso} \PYG{n}{de} \PYG{n}{ensamblado} \PYG{n}{obtendremos} \PYG{n}{un} \PYG{n}{fichero} \PYG{o}{.}\PYG{n}{bin} \PYG{n}{que} \PYG{n}{contiene} \PYG{n}{el} \PYG{n}{código} \PYG{n}{máquina} \PYG{n}{que} \PYG{n}{podremos} \PYG{n}{utilizar} \PYG{n}{directamente} \PYG{n}{en} \PYG{n}{los} \PYG{n}{DATAs} \PYG{n}{de} \PYG{n}{nuestro} \PYG{n}{programa} \PYG{n}{en} \PYG{n}{BASIC}\PYG{o}{.}
\end{sphinxVerbatim}

El fichero .bin es binario, por lo que para obtener los valores numéricos que introducir en los datas debemos utilizar un editor hexadecimal o alguna utilidad como «hexdump» de Linux:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} hexdump \PYGZhy{}C ejemplo1.bin
00000000  21 00 40 3e a2 77 11 01 40 01 ff 1a ed b0 c9
\end{sphinxVerbatim}

Ahí tenemos los datos listos para convertirlos a decimal y pasarlos a sentencias DATA. Si el código es largo y no queremos teclear en DATAs la rutina, podemos convertir el BIN en un fichero TAP ensamblando el programa mediante:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pasmo} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{tap} \PYG{n}{ejemplo1}\PYG{o}{.}\PYG{n}{asm} \PYG{n}{ejemplo1}\PYG{o}{.}\PYG{n}{tap}
\end{sphinxVerbatim}

Este fichero tap contendrá ahora un tap con el código binario compilado tal y como si lo hubieras introducido en memoria y grabado con SAVE «» CODE, para ser cargado posteriormente en nuestro programa BASIC con LOAD «» CODE.

Esta segunda opción (LOAD «» CODE) es la más cómoda, pues nos evita el pokeado de valores en memoria, pero implica ubicar el bloque de datos a cargar con LOAD «» CODE a continuación del programa en BASIC dentro del fichero .tap.

Para realizar esta concatenación escribimos las rutinas en un fichero .ASM y las compilamos con «pasmo \textendash{}tap fichero.asm bloque\_cm.tap». Después, escribimos nuestro programa en BASIC y lo salvamos en cinta, obteniendo otro fichero tap (programa\_basic.tap).

Tras esto tenemos que crear un TAP o un TZX que contenga primero el bloque BASIC y después el bloque de código máquina, de forma que el bloque BASIC podrá cargar el bloque de código máquina con un \sphinxcode{\sphinxupquote{LOAD "" CODE DIRECCION, TAMANYO\_BLOQUE\_CM}}.

Podemos realizar esto con herramientas de gestión de ficheros TAP/TZX o, sin necesidad de utilizar emuladores o herramientas adicionales, mediante concatenación de ficheros:
\begin{itemize}
\item {} 
Linux: \sphinxcode{\sphinxupquote{cat programa\_basic.tap bloque\_cm.tap \textgreater{} programa\_completo.tap}}

\item {} 
Windows: \sphinxcode{\sphinxupquote{copy /b programa\_basic.tap +bloque\_cm.tap programa\_completo.tap}}

\end{itemize}


\section{Generando un binario desde un programa íntegramente en ensamblador}
\label{\detokenize{02_introduccion/introduccion:generando-un-binario-desde-un-programa-integramente-en-ensamblador}}
Si estamos realizando un programa completo en ensamblador, sin ninguna parte en BASIC, deberemos compilar el programa mediante «pasmo \textendash{}tapbas fichero.asm fichero.tap». La opción \textendash{}tapbas añade una cabecera BASIC que carga el bloque código máquina en la dirección indicada por la sentencia ORG del programa en ensamblador (por ejemplo, 40000).

El fichero resultante del ensamblado será un TAP sin autoejecución listo para cargar en el Spectrum y que deberemos lanzar con un RANDOMIZE USR 40000.

Finalmente, si agregamos una sentencia END a nuestro programa y le agregamos la dirección de inicio (ORG) del mismo, en ese caso «pasmo \textendash{}tapbas» agregará el RANDOMIZE USR correspondiente al listado BASIC y el programa se autoejecutará al ser cargado.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; Pruebas de ensamblador para z80\PYGZhy{}asm}
\PYG{c+c1}{; Santiago Romero aka NoP/Compiler}
\PYG{k}{ORG} \PYG{l+m+mi}{40000}
\PYG{n+nf}{LD} \PYG{n+nv}{HL}\PYG{p}{,} \PYG{l+m+mi}{16384}
\PYG{n+nf}{LD} \PYG{n+nv}{A}\PYG{p}{,} \PYG{l+m+mi}{162}
\PYG{n+nf}{LD} \PYG{p}{(}\PYG{n+nv}{HL}\PYG{p}{),} \PYG{n+nv}{A}
\PYG{n+nf}{LD} \PYG{n+nv}{DE}\PYG{p}{,} \PYG{l+m+mi}{16385}
\PYG{n+nf}{LD} \PYG{n+nv}{BC}\PYG{p}{,} \PYG{l+m+mi}{6911}
\PYG{n+nf}{LDIR}
\PYG{n+nf}{RET}
\PYG{k}{END} \PYG{l+m+mi}{40000}            \PYG{c+c1}{; Pasmo añade RANDOMIZE USR 40000}
\end{sphinxVerbatim}

El resultado del ensamblado de este ejemplo con \textendash{}tapbas será directamente ejecutable en un Spectrum con un simple LOAD «».


\section{En resumen}
\label{\detokenize{02_introduccion/introduccion:en-resumen}}
En esta entrega hemos definido las bases del curso de ensamblador de Z80, comenzando por las limitaciones de BASIC y la necesidad de conocer un lenguaje más potente y rápido. Hemos visto qué aspecto tiene el código en ensamblador (aunque todavía no conozcamos la sintaxis) y, muy importante, hemos visto cómo se integra este código en ensamblador dentro de programas en BASIC.

Por último, hemos conocido una utilidad (pasmo) que nos permitirá, a lo largo del curso, ensamblar todos los programas que realicemos, así como probarlos en un emulador o integrar rutinas en nuestros programas BASIC.


\chapter{Arquitectura y funcionamiento del Spectrum}
\label{\detokenize{03_arquitectura/arquitectura:arquitectura-y-funcionamiento-del-spectrum}}\label{\detokenize{03_arquitectura/arquitectura::doc}}

\section{La Arquitectura del Spectrum}
\label{\detokenize{03_arquitectura/arquitectura:la-arquitectura-del-spectrum}}
Antes de comenzar a programar en lenguaje ensamblador para Spectrum necesitamos conocer su arquitectura: ¿qué hay dentro de nuestro pequeño ordenador y cómo funciona internamente? ¿Cómo procesa las instrucciones código máquina?

En BASIC muchas veces podemos olvidarnos de los detalles a nivel de hardware (precisamente ese es el objetivo de un lenguaje de Alto Nivel como es BASIC), pero en ensamblador no: al escribir los programas en un lenguaje con traducción directa al código máquina es imprescindible conocer cómo funciona internamente el procesador al cual le estamos dando instrucciones.

En este capítulo veremos una visión simplificada de la arquitectura hardware del Spectrum pero que en el fondo es todo lo que necesitaremos para el desarrollo de la mayoría de programas. Bajar hasta el nivel de la electrónica en sí sería una labor para otro tipo de cursos y tendría su principal aplicación en el desarrollo de hardware más que de software.

Comencemos con un esquema de cómo es internamente nuestro Spectrum a nivel de hardware, y después comentaremos uno a uno los elementos que lo componen:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{esquema_zx}.png}
\caption{Arquitectura del Spectrum}\label{\detokenize{03_arquitectura/arquitectura:id1}}\end{figure}

En un vistazo general, podemos ver que el microprocesador Z80 se conecta mediante los puertos de entrada/salida de la CPU a los periféricos externos (teclado, cassette y altavoz de audio), pudiendo leer el estado de los mismos (leer del teclado, leer del cassette) y escribir en ellos (escribir en el altavoz para reproducir sonido, escribir en el cassette) por medio de estas conexiones conocidas como «I/O Ports».

Al mismo tiempo, los Buses de Datos y de Direcciones conectan al microprocesador con la memoria. Esta conexión es la que permite que el Z80 pueda leer y escribir en cualquier posición de la RAM, y leer datos de la ROM (que, juntas, conforman la totalidad de la memoria disponible).

Cuando encendemos el Spectrum, el microprocesador Z80 se dedicada a leer valores de la memoria, decodificar a qué instrucción se corresponde el valor que acaba de leer, y ejecutarlo, continuando el proceso con la siguiente posición de memoria. Así pues, empezando por la posición 0000, el Spectrum comienza a leer instrucciones y a ejecutarlas, una a una.

Al comienzo de la memoria, desde la posición 0 hasta la 16384 (16KB) tenemos mapeada la ROM (Read Only Memory o memoria de sólo lectura) del Spectrum, que contiene instrucciones de programa preprogramadas y que no podemos modificar: contiene las funciones básicas del «sistema operativo» del Spectrum, incluyendo el intérprete de BASIC.

Después de estos primeros 16KB de memoria (la ROM) viene el resto de la memoria disponible: la memoria RAM (Random Access Memory o memoria de acceso aleatorio). Esta es la parte de la memoria en la que nuestros programas pueden trabajar: en ella alojaremos el código del programa, las variables del mismo, etc.

Por otro lado, el microprocesador Z80 tiene una serie de registros internos con los que trabaja y que son los que manipula y utiliza para ejecutar las instrucciones almacenadas en la memoria.

Por último, el puerto de expansión del Spectrum permite conectar nuevos periféricos (como el adaptador de Joystick Kempston o el Interface 1 ó 2) directamente a las patillas de la CPU, ampliando las funcionalidades del ordenador.

Veamos más detalladamente los diferentes componentes de la arquitectura del Spectrum, y cómo funcionan.


\section{El microprocesador Z80}
\label{\detokenize{03_arquitectura/arquitectura:el-microprocesador-z80}}
Como podemos distinguir en el esquema, el cerebro de nuestro Spectrum es un microprocesador Zilog Z80A a 3,54Mhz. Un microprocesador es un circuito integrado que consta (principalmente) de registros, microcódigo, puertos de entrada/salida, un bus de datos y uno de direcciones.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{z80}.jpg}
\caption{El microprocesador Zilog Z80}\label{\detokenize{03_arquitectura/arquitectura:id2}}\end{figure}

Los registros son contenedores de valores numéricos que residen dentro de la misma CPU. En el caso del Z80, tiene 2 juegos de registros (los registros en uso, y los registros alternativos o shadow).

Cada uno de los 2 juegos de registro está formado por las mismas «piezas»: Tenemos por un lado registros de un byte como \sphinxstylestrong{A}, \sphinxstylestrong{F}, \sphinxstylestrong{B}, \sphinxstylestrong{C}, \sphinxstylestrong{D}, \sphinxstylestrong{E}, \sphinxstylestrong{H}, \sphinxstylestrong{L}, \sphinxstylestrong{I} y \sphinxstylestrong{R}, y registros de dos bytes como \sphinxstylestrong{IX}, \sphinxstylestrong{IY}, \sphinxstylestrong{SP} y \sphinxstylestrong{PC}. Los registros de un byte pueden contener valores de 8 bits, es decir, de 0 a 255, y los de 2 bytes pueden contener valores de 16 bits (0\sphinxhyphen{}65535).

Algunos de los registros que hemos nombrado pueden agruparse para formar registros de mayor tamaño y así poder realizar operaciones que requieran valores mayores que los que se pueden representar con 8 bits. Por ejemplo, \sphinxstylestrong{H} y \sphinxstylestrong{L} pueden formar juntos el registro \sphinxstylestrong{HL} con el que realizar operaciones de 16 bits concretas.

Veremos los registros en detalle en el próximo capítulo (así como el segundo juego de registros disponible), pero podemos hacernos a la idea de que los registros son simples variables de 8 ó 16 bits que utilizaremos en nuestros programas en ensamblador. Así, podremos cargar un valor en un registro (\sphinxstylestrong{LD A, 25}), sumar un registro con otro (\sphinxstylestrong{ADD A, B}), activar o desactivar determinados bits de un registro (\sphinxstylestrong{SET 7, A}), etc.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{debugger1}.png}
\caption{Depurador del emulador FUSE}\label{\detokenize{03_arquitectura/arquitectura:id3}}\end{figure}

El juego de registros es todo lo que tenemos (aparte de la memoria) para realizar operaciones en nuestro programa: siempre que estemos operando con datos o utilizando variables, tendrá que ser por fuerza un registro, o una posición de memoria que usemos como variable. Por ejemplo, podemos escribir el siguiente programa en ensamblador, que sumaría dos números:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{n+nf}{LD} \PYG{n+nv}{A}\PYG{p}{,} \PYG{l+m+mi}{10}
   \PYG{n+nf}{LD} \PYG{n+nv}{B}\PYG{p}{,} \PYG{l+m+mi}{20}
   \PYG{n+nf}{ADD} \PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}

\PYG{n+nf}{El} \PYG{n+nv}{anterior} \PYG{n+nv}{programa}\PYG{p}{,} \PYG{n+nv}{una} \PYG{n+nv}{vez} \PYG{n+nv}{ensamblado} \PYG{n+nv}{y} \PYG{n+nv}{ejecutado} \PYG{n+nv}{en} \PYG{n+nv}{un} \PYG{n+nv}{Z80}\PYG{p}{,} \PYG{n+nv}{vendría} \PYG{n+nv}{a} \PYG{n+nv}{decir}\PYG{p}{:}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Carga en el registro A el valor «10».

\item {} 
Carga en el registro B el valor «20».

\item {} 
Suma el valor del registro A con el del registro B y deja el resultado en el registro A (A=A+B).

\end{itemize}

Tras ejecutar el anterior programa en un Z80, el contenido del registro A sería 30 (10+20).

Cuando tratemos las diferentes instrucciones del Z80 veremos en más detalle los registros, su tamaño, cómo se agrupan, y de qué forma podemos usarlos para operar entre ellos y realizar nuestras rutinas o programas.

Finalmente, existe un registro especial del procesador llamado PC (Program Counter, o Contador de Programa). Este registro es de 16 bits (puede contener un valor entre 0 y 65535), y su utilidad es la de apuntar a la dirección de memoria de la siguiente instrucción a ejecutar. Así, cuando arrancamos nuestro Spectrum, el registro PC vale \$0000, con lo que lo primero que se ejecuta en el Spectrum es el código que hay en \$0000. Una vez leído y ejecutado ese primer código de instrucción, se incrementa PC para apuntar al siguiente, y así continuadamente.

Los programas se ejecutan linealmente mediante un ciclo basado en: Leer instrucción en la dirección de memoria apuntada por PC, incrementar registro PC, ejecutar instrucción. Posteriormente veremos más acerca de PC.

Ya hemos visto qué son los registros del microprocesador. Ahora bien, en el ejemplo anterior, ¿cómo sabe el microprocesador qué tiene que hacer cuando se encuentra un comando «LD» o «ADD»? Esto es tarea del microcódigo. El microcódigo del microprocesador es una definición de qué tiene que hacer el microprocesador ante cada una de las posibles órdenes que nosotros le demos.

Por ejemplo, cuando el microprocesador está ejecutando nuestro anterior programa y lee los valores numéricos correspondientes a «LD A, 10», el Z80 utiliza el microcódigo encargado de mover el valor 10 al registro A. Este microcódigo no es más que una secuencia de señales hardware y cambios de estados electrónicos cuyo resultado será, exactamente, activar y desactivar BITs en el registro A (que no es más que una serie de 8 biestables electrónicos que pueden estar a 0 voltios o a 5 voltios cada uno de ellos, representando el estado de los 8 bits del registro A). Lo mismo ocurrirá cuando se lea la instrucción «LD B, 20», sólo que se ejecutará otra porción de microcódigo que lo que hará será modificar el registro B.

Este microcódigo está dentro del microprocesador porque sus diseñadores implementaron todas y cada una de las operaciones que puede hacer el Z80. Cuando pedimos meter un valor en un registro, leer el valor de un registro, sumar un registro con otro, escribir el valor de un registro en una dirección de memoria, saltar a otra parte del programa, etc, para cada una de esas situaciones, hay un microcódigo (implementado mediante hardware) que realiza esa tarea.

Nosotros no tendremos que preocuparnos pués de cómo hace el Z80 las cosas internamente a nivel de microcódigo, aunque es bueno que conozcáis cómo llega el Spectrum a ejecutar nuestros comandos: gracias al microcódigo.


\section{Puertos de entrada/salida}
\label{\detokenize{03_arquitectura/arquitectura:puertos-de-entrada-salida}}
Si examinamos físicamente un microprocesador Z80A, podremos distinguir 40 patillas o pines de conexión. Además de los pines que se utilizan para alimentar el Z80 desde la fuente de alimentación, existen otra serie de patillas para «Puertos de Entrada/Salida» y «Bus de datos y de direcciones». Éstas se utilizan para la conexión del microprocesador con el resto de elementos del ordenador

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{pinout}.png}
\caption{Patillas del Z80}\label{\detokenize{03_arquitectura/arquitectura:id4}}\end{figure}

Los registros del microprocesador y el microcódigo son hardware interno del procesador, y ninguna de las patillas que podemos ver en la imagen anterior nos comunica con ellos. Es el procesador (internamente) quien lee/modifica los registros o quien ejecuta microcódigo cuando nosotros se lo decimos mediante las instrucciones de nuestro programa.

Pero nuestro procesador, como hemos dicho, necesita conectarse con elementos del exterior, entre ellos (y casi exclusivamente en el caso del Spectrum) tenemos la memoria, el teclado, el altavoz y la unidad de cinta.

Visto de un modo muy simple, el Z80 puede acceder a través de una serie de patillas a múltiples elementos externos. Esos elementos se conectan a la CPU Z80 a través de las patillas de «Buses de datos y direcciones» (que podemos leer en los puertos de Entrada/Salida). Una vez conectados (la conexión se realiza físicamente a nivel de hardware, con pistas en la placa base del Spectrum), el microprocesador Z80 puede leer los valores que el dispositivo pone en esas pistas, o puede escribir valores en esas pistas para que el dispositivo los utilice.

Supongamos el ejemplo del teclado: un teclado es (a un nivel muy simple) una matriz de pulsadores. Al final de toda esa matriz de pulsadores, lo que acabamos teniendo es un valor numérico cuyos bits nos indican la teclas pulsadas. Pues bien, esos bits es lo que el mismo teclado pone en los «cables» que lo unen con el Z80, concretamente en el bus de datos.

El teclado se conecta a la CPU mediante conexión a los buses de direcciones y de datos y gracias a esto el microprocesador (y nuestro programa) puede leer en todo momento su estado (y saber qué teclas están pulsadas y cuales no) leyendo del puerto correspondiente.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{teclado}.jpg}
\caption{Conexiones del teclado}\label{\detokenize{03_arquitectura/arquitectura:id5}}\end{figure}

Así, en nuestros programas podemos leer el estado del teclado mediante (por ejemplo):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nl}{5}\PYG{+w}{  }\PYG{c+c1}{REM Mostrando el estado de la fila 1\PYGZhy{}5 del teclado}
\PYG{n+nl}{10}\PYG{+w}{ }\PYG{k+kd}{LET}\PYG{+w}{ }\PYG{n+nv+vg}{puerto}\PYG{o}{=}\PYG{l+m+mi+il}{63486}
\PYG{n+nl}{20}\PYG{+w}{ }\PYG{k+kd}{LET}\PYG{+w}{ }\PYG{n+nv+vg}{V}\PYG{o}{=}\PYG{n+nv+vg}{IN}\PYG{+w}{ }\PYG{n+nl}{puerto:}\PYG{+w}{ }\PYG{k+kr}{PRINT}\PYG{+w}{ }\PYG{n+nv+vg}{AT}\PYG{+w}{ }\PYG{l+m+mi+il}{20}\PYG{p}{,}\PYG{l+m+mi+il}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n+nv+vg}{V}\PYG{+w}{ }\PYG{p}{;}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}  \PYGZdq{}}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n+nv+vg}{GO}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{l+m+mi+il}{20}
\end{sphinxVerbatim}

Este ejemplo lee (en un bucle infinito) una de las diferentes filas del teclado, mediante la lectura del puerto 63486 (F7FEh) con la instrucción de lectura de puertos de BASIC «IN». El estado de las 5 teclas que van desde el «1» hasta el «5» del teclado del Spectrum está conectado a 5 «hilos» de los 8 que llegan al puerto 63486 del micro Z80.

Si no hay ninguna tecla pulsada, el estado de estos 5 bits será un «1» lógico, que a nivel de hardware serán 5 Voltios. Cuando se pulsa una tecla, el teclado pone a «0» lógico (a 0 voltios) el «hilo» correspondiente de esos 8, y nosotros podemos conocer el estado de la tecla leyendo dicho puerto y mirando el bit en cuestión.

Al ejecutar el ejemplo BASIC anterior, veremos que la pulsación de la tecla «1» cambiará el valor que aparece en pantalla. Si pasamos los diferentes valores que aparecen a binario y nos fijamos en el estado de los 5 últimos bits, nos daremos cuenta como al pulsar y soltar las diferentes teclas del 1 al 5 estaremos variando esos bits entre 0 (al pulsarlas) y 1 (al liberarlas). Los 3 bits más altos del byte debemos ignorarlos en nuestro ejemplo, ya que no tienen relación con el teclado.

En resumen: Si no hay ninguna tecla pulsada, los 5 bits más bajos del byte que hay en el puerto estarán todos a 1, mientras que si se pulsa alguna de las teclas del 1 al 5, el bit correspondiente a dicha tecla pasará a estado 0. Nosotros podemos leer el estado del puerto y saber, mirando los unos y los ceros, si las teclas están pulsadas o no. Esto es posible gracias a la interconexión del teclado (un periférico) y el microprocesador a través del bus de direcciones (el identificador que permite al microprocesador saber qué puerto queremos leer) y de datos (el lugar donde recogemos el valor puesto por el periférico).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{leer_teclado}.png}
\caption{Pulsando «1» ponemos 1 el bit 0}\label{\detokenize{03_arquitectura/arquitectura:id6}}\end{figure}

Así, leyendo del puerto 63486 obtenemos un byte cuyos 8 bits tienen como significado el estado de cada una de las teclas de la semifila del «1» al «5».


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Bits
&\sphinxstyletheadfamily 
D7
&\sphinxstyletheadfamily 
D6
&\sphinxstyletheadfamily 
D5
&\sphinxstyletheadfamily 
D4
&\sphinxstyletheadfamily 
D3
&\sphinxstyletheadfamily 
D2
&\sphinxstyletheadfamily 
D1
&\sphinxstyletheadfamily 
D0
\\
\hline
Teclas
&
XX
&
XX
&
XX
&
«5»
&
«4»
&
«3»
&
«2»
&
«1»
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Los bits D7 a D5 no nos interesan en el caso del teclado (por ejemplo, D6 tiene relación con la unidad de cinta), mientras que los bits de D5 a D0 son bits de teclas (0=pulsada, 1=no pulsada).

Tenemos pues el teclado dividido en filas de teclas y disponemos de una serie de puertos para leer el estado de cada una de ellas:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Puerto
&\sphinxstyletheadfamily 
Teclas
\\
\hline
65278d (FEFEh)
&
de CAPS SHIFT a V
\\
\hline
65022d (FDFEh)
&
de A a G
\\
\hline
64510d (FBFEh)
&
de Q a T
\\
\hline
63486d (F7FEh)
&
de 1 a 5 (and JOYSTICK 1)
\\
\hline
61438d (EFFEh)
&
de 6 a 0 (and JOYSTICK 2)
\\
\hline
57342d (DFFEh)
&
de P a Y
\\
\hline
49150d (BFFEh)
&
de ENTER a H
\\
\hline
32766d (7FFEh)
&
de (space) a B
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

A la hora de leer estos puertos, el bit menos significativo (D0) siempre hace referencia a la tecla más alejada del centro del teclado («1» en nuestro ejemplo), mientras que el más significativo de los 5 (D5) lo hace a la tecla más cercana al centro del teclado.

En ensamblador también hay disponibles 2 instrucciones para leer el contenido de un puerto de Entrada/Salida y para escribir un valor en un puerto determinado, las instrucciones se llaman igual que en BASIC: IN y OUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{; Cargamos en BC el valor del puerto a leer}
\PYG{n+nf}{LD} \PYG{n+nv}{BC}\PYG{p}{,} \PYG{n+nv}{F7FEh}

\PYG{c+c1}{; Leemos en el registro A el valor del puerto}
\PYG{n+nf}{IN} \PYG{n+nv}{A}\PYG{p}{,} \PYG{p}{(}\PYG{n+nv}{C}\PYG{p}{)}
\end{sphinxVerbatim}

Hemos mostrado el ejemplo del teclado, aunque estamos todavía empezando y puede haber sido algo complicado de entender, por diferentes motivos:
\begin{itemize}
\item {} 
El primero, explicar con un ejemplo práctico qué son los puertos de E/S y cómo están conectados a nivel de hardware con el microprocesador. Como habéis visto, del teclado salen una serie de «hilos» o pistas de circuito impreso que van directamente al Z80A (en el caso del Spectrum, a través de la ULA), mediante conexión a sus diferentes buses y puertos.

\item {} 
Mostrar cómo nosotros podemos, en cualquier momento, leer y escribir en los puertos de E/S. Con esto conseguimos comunicarnos con los periféricos externos. En este caso, podemos leer del teclado (o escribir o leer del cassette, o en el altavoz) con simples operaciones de lectura y escritura IN y OUT.

\end{itemize}

El lector debería extraer una conclusión adicional del ejemplo del teclado: la gran diferencia de proceso que hay entre programar en ensamblador y programar en BASIC. Supongamos que nos interesa leer el estado del teclado para saber si unas determinadas teclas están pulsadas o no. Para esto, en ensamblador (aunque esto también podemos hacerlo en BASIC) leemos directamente el estado del teclado con un par de simples instrucciones (LD + IN).

En BASIC, por contra, al usar INKEY\$ estamos esperando la ejecución de un código que, además de leer TODAS las filas del teclado (no sólo aquellas de las teclas que nos interesen), realiza una conversión de todos los bits pulsados o no pulsados mediante una tabla para al final proporcionarnos el código ASCII de la tecla pulsada.

Lo que son varias instrucciones simples en ASM, en BASIC se realiza mediante cientos de instrucciones en ensamblador que nos acaban dando la última tecla pulsada. Es por eso que el intérprete BASIC es tan lento: cada operación BASIC son decenas, cientos o miles de instrucciones en ensamblador que ni vemos ni controlamos. Programando directamente en ASM, el microprocesador hará EXCLUSIVAMENTE lo que nosotros le digamos que haga. He aquí la «mágica» diferencia de velocidad entre ambos lenguajes.

Podéis encontrar más información sobre los puertos de Entrada y Salida en el capítulo 8 sección 32 del manual del +2A y +3, que tenéis disponible online en World Of Spectrum.


\section{Memoria}
\label{\detokenize{03_arquitectura/arquitectura:memoria}}
Al igual que en el caso de los puertos de entrada/salida, nuestro microprocesador está también conectado a los diferentes chips de memoria (hablamos en plural porque, físicamente, hay más de uno). La conexión se realiza siguiendo unas normas definidas por los ingenieros de Sinclair, de tal forma que la memoria se mapea linealmente. ¿Qué quiere decir esto? Que aunque tengamos varios chips de memoria, vemos la memoria como una gran y única memoria de 64KB (en el caso del modelo de 48KB).

El Spectrum 48KB básico (48KB de RAM y 16KB de ROM) tiene disponibles 64KB de memoria, es decir, 65536 bytes a los cuales podemos acceder. Podemos pensar en esta memoria como un gran baúl con 65536 cajones, uno encima de otro. El primer cajón es el cajón 0 (posición de memoria 0), el segundo el cajón 1 (posición de memoria 1), y así hasta el cajón 65535 (posición de memoria 65535).

Nuestro Spectrum no puede tener más de 65536 cajones porque el «bus de direcciones» del microprocesador Z80 es de 16 bits, es decir, las líneas que conectan al microprocesador con la memoria sólo permiten 16 «conexiones»; lo que nos da la posibilidad de acceder a 2 elevado a 16 bytes de memoria, exactamente 65536 bytes.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=1.0]{{memoria}.png}
\caption{Aspecto de nuestras 65535 celdas de memoria}\label{\detokenize{03_arquitectura/arquitectura:id7}}\end{figure}

Cada uno de estos cajones (más técnicamente, «celdillas de memoria» o «posiciones de memoria») puede contener un número de 8 bits, con un valor, por tanto, entre 0 y 255. Esto es así porque el «bus de datos» del microprocesador Z80 es de 8 bits, lo que implica que «sólo hay 8 conexiones» entre la salida de datos de la memoria y nuestro procesador.

El microprocesador Z80 puede acceder a cualquier posición de memoria tanto para leer como para escribir. Internamente, cuando le pedimos al microprocesador que meta en el registro A el contenido de la celdilla de memoria \$1234, mediante una instrucción de ensamblador «LD A, (\$1234)» lo que hace el microprocesador internamente es:

(Nota: el operador () (paréntesis abierto y cerrado) en ensamblador significa acceso a memoria).


\subsection{Ejecución de: LD A, (\$1234)}
\label{\detokenize{03_arquitectura/arquitectura:ejecucion-de-ld-a-1234}}\begin{itemize}
\item {} 
\$1234 en binario es 00010010 00110100, de modo que el Z80 coge las 16 líneas que conectan al microprocesador con la memoria y las pone a esos estados (0 = 0 voltios, 1 = 5 voltios).

\item {} 
A continuación, el microprocesador utiliza una conexión especial que le conecta con la memoria para indicarle qué operación quiere realizar. Poniendo al valor apropiado la línea de control que le comunica con la memoria, el Z80 informa al chip de memoria de que quiere realizar una operación de lectura.

\item {} 
La memoria recibe la señal de «deseo leer un dato» por esta señal de control, y mira el bus de direcciones que le conecta con el Spectrum. Mirando el estado de las 16 líneas encuentra el «00010010 00110100» (\$1234). Con eso, la memoria sabe a qué «casilla» o «cajón» quiere acceder el microprocesador.

\item {} 
La memoria lee el valor de la celdilla de memoria \$1234 (supongamos que contiene, por ejemplo \$0F, que es 00001111 en binario) y cambia las 8 conexiones del Bus de Datos para que contengan 00001111 (4 «líneas» las pone a 0 voltios, y las otras 4 a 5 voltios).

\item {} 
El Z80 consulta el bus de datos y ve el estado de las líneas, con lo que lee el «00001111» o 0Fh.

\item {} 
El Z80 coloca en el registro A el valor \$0F

\end{itemize}

El procedimiento para escribir es similar, salvo que la línea de control entre el Z80 y la memoria en lugar de indicar «lectura» indica «escritura», y que es el Z80 quien pone en el bus de datos el valor que quiere escribir en la celdilla indicada en el bus de direcciones:


\subsection{Ejecución de: LD (\$1234), A}
\label{\detokenize{03_arquitectura/arquitectura:ejecucion-de-ld-1234-a}}\begin{itemize}
\item {} 
Supongamos que A contiene el valor 15 (\$0F): el Z80 coloca las líneas del bus de datos a los valores 00001111 (donde cada 0 es 0 Voltios y cada 1 son 5 Voltios).

\item {} 
El Z80 coloca las líneas del bus de direcciones a 00010010 00110100 (\$1234).

\item {} 
A continuación, el microprocesador pone las línea de control de Lectura y Escritura de memoria a tal valor que la memoria sabe que el Z80 le pide una operación de escritura.

\item {} 
La memoria recibe la señal de «deseo escribir un dato», y mira el bus de direcciones que le conecta con el Spectrum. Obteniendo el estado de las 16 líneas encuentra el «00010010 00110100» (\$1234). Con eso, la memoria sabe a qué «casilla» o «cajón» quiere acceder el microprocesador para escribir.

\item {} 
La memoria lee el valor del bus de datos para saber qué dato tiene que escribir y obtiene el valor \$0F.

\item {} 
La memoria escribe en su celdilla número \$1234 el valor \$0F.

\end{itemize}

Estas son las 2 operaciones básicas que el Z80 puede realizar con la memoria: leer una posición de memoria y escribir en una posición de memoria. Nosotros no tenemos que preocuparnos de ninguna de las señales hardware necesarias para realizar lecturas y escrituras, de eso se encarga el microprocesador. Para nosotros, a nivel de ensamblador, nos bastará con ejecutar «LD A, (\$1234)» o «LD (\$1234), A», por ejemplo.

Las celdillas de memoria desde la nº 0 a la 16383 están ocupadas por un chip que es la ROM del Spectrum. Este chip es de sólo lectura (ROM = Read Only Memory), lo cual quiere decir que si intentamos escribir en las celdillas desde la 0 a la 16383 no conseguiremos cambiar el valor almacenado en ellas. ¿Por qué no se puede escribir aquí? Porque es la ROM del Spectrum, es un chip que contiene el «sistema operativo» del Spectrum, su intérprete BASIC, como veremos posteriormente.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{romram}.png}
\caption{ROM y RAM}\label{\detokenize{03_arquitectura/arquitectura:id8}}\end{figure}

Para trabajar (ejecutar programas, realizar operaciones y tareas) podemos utilizar el resto de la memoria. Desde el cajón o celdilla número 16384 hasta el 65535 (en los modelos de 48KB) podremos escribir y leer.

La memoria RAM (celdillas 16384 a 65536) es muy importante para el Spectrum. Para empezar, en ella es donde se almacenan los datos y donde se cargan los programas, y de ella es de donde lee el microprocesador estos programas (como veremos posteriormente) para ejecutarlos instrucción a instrucción. Cuando en nuestra anterior entrega del curso pokeamos la rutina en código máquina en la dirección 40000, estabamos escribiendo un programa en memoria RAM para después ejecutarlo.

Hay una parte de la memoria RAM que es especial. El trozo de 6912 bytes que va desde la dirección 16384 hasta la 23295 es conocida como VideoRAM. Esta porción de la memoria no se utiliza para almacenar programas ni datos, sino que es una representación numérica de los gráficos que aparecen en nuestro televisor. La ULA (un chip que hay dentro de nuestro Spectrum) lee continuamente esta zona de memoria y transforma los unos y ceros que en ella encuentra en puntos y colores en el televisor.

Visto de una manera simple (pero real): al escribir un valor numérico (por ejemplo un 1) en alguna dirección de esta parte de la RAM, de forma inmediata aparece un punto en nuestro televisor, ya que la ULA está continuamente «escaneando» la videoram (de forma independiente del Z80) para reflejar en el televisor todos los valores numéricos que introduzcamos en ella.

La videomemoria es memoria RAM normal y corriente (podemos tanto leer como escribir en ella), sólo que los datos que contiene son leídos por la ULA a un ritmo de 50 veces por segundo. La ULA convierte los datos de la videomemoria en la imagen que vemos en el televisor conectado a nuestro Spectrum. La ULA es, pues, el chip encargado de representar en el televisor el contenido de la videomemoria y nosotros, cuando queramos escribir o dibujar algo en pantalla, ya no utilizaremos funciones como PLOT o DRAW de BASIC, sino que escribiremos directamente valores en esta zona de memoria.

Por ejemplo, el siguiente programa pinta 2 píxeles en el centro de la pantalla escribiendo en la videomemoria:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nl}{10}\PYG{+w}{ }\PYG{c+c1}{REM Pintando 2 pixeles en pantalla mediante POKE}
\PYG{n+nl}{20}\PYG{+w}{ }\PYG{k+kd}{LET}\PYG{+w}{ }\PYG{n+nv+vg}{DIRECCION}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi+il}{16384}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi+il}{2000}
\PYG{n+nl}{25}\PYG{+w}{ }\PYG{c+c1}{REM 129 = 10000001}
\PYG{n+nl}{30}\PYG{+w}{ }\PYG{k+kr}{POKE}\PYG{+w}{ }\PYG{n+nv+vg}{DIRECCION}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi+il}{129}
\PYG{n+nl}{40}\PYG{+w}{ }\PYG{n+nv+vg}{PAUSE}\PYG{+w}{ }\PYG{l+m+mi+il}{0}
\end{sphinxVerbatim}

Si ejecutamos el programa, veremos 2 puntos en el centro de la pantalla. Estos 2 puntos aparecen al escribir el byte de valor 129 en la dirección 18384. El número 129, en binario, es 10000001. Esos 2 unos son los que se convierten en 2 puntos cuando la ULA lee la videomemoria y transforma los unos en colores de tinta y los ceros en colores de papel.

Lo que nos tiene que quedar claro al respecto de la memoria es lo siguiente:
\begin{itemize}
\item {} 
El microprocesador puede acceder a la memoria tanto para leer como para escribir, y lo hará cuando nosotros se lo pidamos (para leer o escribir datos en memoria). También lo hará para leer las instrucciones a ejecutar, como veremos posteriormente.

\item {} 
La memoria se divide en ROM (celdillas 0\sphinxhyphen{}16383) y RAM (celdillas desde 16384 hasta la totalidad de memoria instalada), con los primeros 6912 bytes de la RAM mapeados como VideoRAM.

\item {} 
En la ROM no podemos escribir (pero sí leer). Almacena el «código» de arranque del Spectrum, así como el intérprete de BASIC. En ella existen rutinas que usa BASIC que podremos aprovechar en nuestros programas en ensamblador.

\item {} 
En la videoRAM sólo leeremos y escribiremos (en nuestro caso) cuando queramos dibujar cosas en pantalla (puntos y colores).

\item {} 
En el resto de la RAM (a partir de la dirección 23296) es donde realizaremos todo el trabajo: allí situaremos nuestros programas, nuestras variables, datos, gráficos que después copiaremos a la videoRAM, etc.

\end{itemize}


\section{El puerto de expansión}
\label{\detokenize{03_arquitectura/arquitectura:el-puerto-de-expansion}}
El puerto de expansión del Spectrum no será en principio tema de discusión en este libro, ya que no lo utilizaremos en nuestros programas. Para información del lector, basta con saber que algunos de los pines del puerto de expansión del Spectrum están conectados directamente a diferentes patillas del microprocesador. Es decir, cada una de las líneas que podemos ver físicamente en el puerto de expansión es una pista de circuito (como si fuera un cable) que va directamente a alguna de las patillas del Z80.

Es por eso que mediante el puerto de expansión se puede implementar casi cualquier dispositivo hardware en el Spectrum sin tener que abrirlo y manipularlo internamente: estamos conectando dipositivos directamente al microprocesador y tras hacerlo, podemos realizar programas que accedan a esos elementos recién conectados: podemos leer los joysticks (porque los estamos conectando a puertos de Entrada/Salida mediante los buses de datos y direcciones), podemos leer cartuchos (porque «ocultamos» la memoria del Spectrum y la reemplazamos con otra memoria que contiene el juego ya cargado en ella, poniéndo esta memoria en el Bus de datos y Direcciones), etc.


\section{Cómo funciona el Spectrum}
\label{\detokenize{03_arquitectura/arquitectura:como-funciona-el-spectrum}}
Una vez hemos visto todas las partes funcionales, veamos cómo funciona el Spectrum a nivel de ciclo de instrucción y ejecución.

Como ya hemos visto, los diferentes dispositivos externos (teclado, altavoz, cassette, elementos conectados al puerto de expansión, joysticks) se comunican con la CPU por medio de puertos de Entrada/Salida (Puertos E/S o I/O Ports). Para acceder a ellos simplemente leemos o escribimos en el puerto correspondiente mediante las instrucciones IN y OUT del Z80. También existen instrucciones para acceder a la memoria, tanto para lectura como para escritura.

En realidad el Z80, visto de una forma simplificada, sólo puede hacer 3 cosas: leer/escribir en la memoria, leer/escribir en los dispositivos de Entrada/Salida y decodificar/ejecutar instrucciones. La parte de lectura/decodificación/ejecución es el funcionamiento principal del microprocesador, y es lo que trataremos a continuación.


\section{Ciclo de ejecución de un Spectrum}
\label{\detokenize{03_arquitectura/arquitectura:ciclo-de-ejecucion-de-un-spectrum}}
Como ya hemos visto, la parte central del Spectrum es un microprocesador Z80 el cual ve la ROM y la RAM de forma continuada como la totalidad de su memoria. Recordemos que el Spectrum puede leer el contenido de cualquiera de estas 65536 celdillas así como escribir en ellas (siempre que no sean celdillas de la ROM).

Al encender el Spectrum éste se inicializa y muestra el BASIC en pantalla. ¿Por qué ocurre esto? Cuando se inicia el Spectrum, el microprocesador Z80 comienza a ejecutar instrucciones, una tras otra, desde la dirección de memoria 0, donde está el principio de la ROM de 16K, es decir, el intérprete BASIC.

Un microprocesador funciona a grandes rasgos de la siguiente forma:
\begin{itemize}
\item {} 
Leer instrucción apuntada por el registro PC.

\item {} 
Incrementar PC para apuntar a la siguiente instrucción.

\item {} 
Ejecutar la instrucción recién leída.

\item {} 
Repetir continuadamente los 3 pasos anteriores.

\end{itemize}

Al encender un Spectrum (que perdió en su apagado toda alimentación eléctrica) teóricamente todos los registros del microprocesador Z80 valen 0 (sin alimentación eléctrica, todos los bits de la CPU están a 0 Voltios, es decir, a 0 lógico), incluído el registro PC (Program Counter o Contador de Programa), que es el que apunta a la siguiente instrucción que el Z80 debe leer y ejecutar.

Al ser PC = 0000, el Spectrum comienza a ejecutar, instrucción tras instrucción, el código que hay pregrabado en la ROM a partir de la celdilla 0 de memoria.

Visto en pseudocódigo, como si fuera un programa, un Z80 actúa así:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Encendido de ordenador:
    \PYGZhy{} PC (el Contador de Programa) se pone a 0.
    \PYGZhy{} SP se pone a \PYGZdl{}FFFF.
* Mientras No Se Apague el Ordenador:
    Leer de la memoria la siguiente instrucción, mediante
    lectura del contenido de la dirección apuntada por PC:
    \PYGZhy{} Opcode = (PC)
    \PYGZhy{} PC = PC + 1
    \PYGZhy{} Si la instrucción necesita algún operando, leerlo:
        + Operando1 = (PC)
        + PC = PC + 1
    \PYGZhy{} Si hay un segundo operando, leerlo:
        + Operando2 = (PC)
        + PC = PC + 1
    o Decodificar la instrucción (mirar en una tabla interna y ver
    qué microcódigo hay que ejecutar para la instrucción leída).
    o Ejecutar la instrucción
Fin Mientras
\end{sphinxVerbatim}

En realidad, según el texto «The Undocumented Z80 Documented», de Sean Young, tras un reset los registros quedan con los siguientes valores:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
PC              = \PYGZdl{}0000
AF, SP          = \PYGZdl{}FFFF
Resto           = Valor indefinido
Interrupciones
(IM, IFF1 y 2)  = 0
\end{sphinxVerbatim}

Así pues, al encender el ordenador, PC vale 0. Al estar la ROM mapeada en la posición de memoria 0 (mediante cableado hardware de los chips de memoria en la placa del Spectrum), lo que pasa al encender el ordenador es que ese contador de programa (PC) está apuntando al principio de la ROM, y es por eso que se ejecuta la ROM paso a paso, instrucción a instrucción, cada vez que lo encendemos, realizando desde el característico borrado de pantalla del inicio del Spectrum hasta la impresión del tradicional mensaje «© 1982 Sinclair Research Ltd».

Después, la ejecución del código que hay en la ROM se mantiene en un bucle que escanea el teclado y nos permite introducir órdenes de BASIC y ejecutarlas: el famoso intérprete BASIC.

Fuera de los primeros 16KB de memoria tenemos el resto de memoria disponible, donde el intérprete BASIC almacenará las instrucciones BASIC que tecleemos o bien donde se cargará un programa desde los diferentes dispositivos de entrada/salida (gestionados por el Z80) como la cinta o disco, etc.

Así pues, nuestro Z80 en el momento del arranque lo que hace es comenzar a ejecutar una a una las instrucciones código máquina que hay a partir de la dirección \$0000 de la memoria, que se corresponde con la ROM.

¿Y qué contiene la ROM? Pues la ROM no es más que un programa realizado por los ingenieros de Sinclair. Ese programa contiene, entre otras cosas, el intérprete BASIC. Los señores de Sinclair Research programaron un intérprete BASIC en lenguaje ensamblador de Z80, lo ensamblaron con un programa ensamblador de Z80 y grabaron el código binario resultante ensamblado en un CHIP ROM de 16KB. Por eso al encender nuestro Spectrum aparece el intérprete de BASIC; el Sistema Operativo de nuestro ZX. Nada nos impediría realizar nuestro propio «sistema operativo» para Spectrum creando una ROM nueva (mirando siempre la compatibilidad con la ROM vieja, de forma que contenga las mismas rutinas de ROM y variables en memoria que utilizan muchos programas) y reemplazando el chip ROM del Spectrum por nuestro propio chip de ROM.


\section{Opcodes y código máquina}
\label{\detokenize{03_arquitectura/arquitectura:opcodes-y-codigo-maquina}}
Nuestro microprocesador Z80 no entiende los comandos en ensamblador que hemos estado viendo en estos 2 primeros capítulos del curso de código máquina; el Z80 sólo entiende números binarios, números de 8 bits de 0 a 255 (o de \$00 a \$FF en hexadecimal).

De entre los registros del microprocesador hay uno llamado PC (Program Counter o Contador de Programa), que como ya hemos visto, es el «puntero» que apunta a la instrucción actual que se está ejecutando. Cuando ejecutamos un programa, lo que hacemos es meterlo en memoria (por ejemplo, como cuando en la primera entrega del curso POKEábamos nuestra rutina a partir de la dirección 40.000) y después saltar al inicio del mismo.

Supongamos por ejemplo que pokeamos el siguiente programa en la dirección 40000:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{LD} \PYG{n+nv}{A}\PYG{p}{,} \PYG{l+m+mi}{0}
\PYG{n+nf}{INC} \PYG{n+nv}{A}
\PYG{n+nf}{LD} \PYG{n+nv}{B}\PYG{p}{,} \PYG{k+kc}{\PYGZdl{}}\PYG{n+nv}{FFh}
\PYG{n+nf}{INC} \PYG{n+nv}{B}
\PYG{n+nf}{LD} \PYG{n+nv}{DE}\PYG{p}{,} \PYG{k+kc}{\PYGZdl{}}\PYG{n+nv}{AABB}
\PYG{n+nf}{RET}
\end{sphinxVerbatim}

Si ensamblamos este programa obtendremos los siguientes números (técnicamente llamados «código máquina»):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3}\PYG{n}{e} \PYG{l+m+mi}{00} \PYG{l+m+mi}{3}\PYG{n}{c} \PYG{l+m+mi}{06} \PYG{n}{ff} \PYG{l+m+mi}{04} \PYG{l+m+mi}{11} \PYG{n}{bb} \PYG{n}{aa} \PYG{n}{c9}
\end{sphinxVerbatim}

Al pokear en memoria estos valores, dejaremos el siguiente contenido en memoria:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Dirección
&\sphinxstyletheadfamily 
Valor hexadecimal
\\
\hline
40000
&
3e
\\
\hline
40001
&
00
\\
\hline
40002
&
3c
\\
\hline
40003
&
06
\\
\hline
40004
&
ff
\\
\hline
40005
&
04
\\
\hline
40006
&
11
\\
\hline
40007
&
bb
\\
\hline
40008
&
aa
\\
\hline
40009
&
c9
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Para nosotros estos números no quieren decir nada, pero para el Spectrum tienen un total significado. Concretamente:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Dirección
&\sphinxstyletheadfamily 
Valor hexadecimal
&\sphinxstyletheadfamily 
Significado
\\
\hline
40000
&
3e
&
LD A,
\\
\hline
40001
&
00
&
00h
\\
\hline
40002
&
3c
&
INC A
\\
\hline
40003
&
06
&
LD B,
\\
\hline
40004
&
ff
&
FFh
\\
\hline
40005
&
04
&
INC B
\\
\hline
40006
&
11
&
LD DE,
\\
\hline
40007
&
bb
&
BBh
\\
\hline
40008
&
aa
&
AAh
\\
\hline
40009
&
c9
&
RET
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

A la hora de ejecutar el programa, nuestro RANDOMIZE USR 40000 lo que hace en realidad es cambiar el valor del registro «PC» del microprocesador. Hace PC igual a 40000. Así, una vez realizamos el salto a la dirección 40000, el microprocesador hace lo siguiente:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Leer el byte contenido en la dirección de memoria \PYGZdq{}PC\PYGZdq{} (40000).
* Incrementar PC (PC=PC+1).
* El byte es \PYGZdq{}\PYGZdl{}3e\PYGZdq{}, con lo cual el Spectrum sabe que
  tiene que meter en A un valor numérico.
* El valor extra para \PYGZdq{}LD A,\PYGZdq{} está a continuación en memoria,
  así que se lee la memoria de nuevo:
        \PYGZhy{} operando = [PC] = \PYGZdl{}00
        \PYGZhy{} Incrementar PC (PC=PC+1)
* Ya se tiene el \PYGZdq{}código de instrucción completo\PYGZdq{}, así que se
    ejecuta: \PYGZdq{}LD A, 00\PYGZdq{}. (se ejecuta el microcódigo
    correspondiente dentro de la CPU).
\end{sphinxVerbatim}

Esto que hemos visto es el proceso de «Lectura de Instrucción (fetch)», «decodificación (decode)», y «ejecución (execute)». Pero recordemos que este proceso se ejecuta una y otra vez, sin parar, de modo que el procesador sigue con la siguiente instrucción (INC A):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*} \PYG{n}{Leer} \PYG{n}{el} \PYG{n}{byte} \PYG{n}{contenido} \PYG{n}{en} \PYG{n}{la} \PYG{n}{dirección} \PYG{n}{de} \PYG{n}{memoria} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{(}\PYG{l+m+mi}{40002}\PYG{p}{)}\PYG{o}{.}
\PYG{o}{*} \PYG{n}{Incrementar} \PYG{n}{PC} \PYG{p}{(}\PYG{n}{PC}\PYG{o}{=}\PYG{n}{PC}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}
\PYG{o}{*} \PYG{n}{El} \PYG{n}{byte} \PYG{n}{es} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}3c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{con} \PYG{n}{lo} \PYG{n}{cual} \PYG{n}{el} \PYG{n}{Spectrum} \PYG{n}{sabe} \PYG{n}{que} \PYG{n}{tiene} \PYG{n}{que} \PYG{n}{incrementar} \PYG{n}{A}\PYG{o}{.}
\PYG{o}{*} \PYG{n}{No} \PYG{n}{hacen} \PYG{n}{falta} \PYG{n}{operandos} \PYG{n}{extra}\PYG{p}{,} \PYG{n}{INC} \PYG{n}{A} \PYG{n}{no} \PYG{n}{requiere} \PYG{n}{nada} \PYG{n}{más}\PYG{o}{.}
\PYG{o}{*} \PYG{n}{Ya} \PYG{n}{se} \PYG{n}{tiene} \PYG{n}{el} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{código de instrucción completo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{así} \PYG{n}{que} \PYG{n}{se} \PYG{n}{ejecuta}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INC A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}
\end{sphinxVerbatim}

Y este ciclo se vuelve a repetir, una y otra vez, hasta que llegamos al RET:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*} \PYG{n}{Leer} \PYG{n}{el} \PYG{n}{byte} \PYG{n}{contenido} \PYG{n}{en} \PYG{n}{la} \PYG{n}{dirección} \PYG{n}{de} \PYG{n}{memoria} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{(}\PYG{l+m+mi}{40009}\PYG{p}{)}\PYG{o}{.}
\PYG{o}{*} \PYG{n}{Incrementar} \PYG{n}{PC} \PYG{p}{(}\PYG{n}{PC}\PYG{o}{=}\PYG{n}{PC}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}
\PYG{o}{*} \PYG{n}{El} \PYG{n}{byte} \PYG{n}{es} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}c9}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{con} \PYG{n}{lo} \PYG{n}{cual} \PYG{n}{el} \PYG{n}{Spectrum} \PYG{n}{sabe} \PYG{n}{que} \PYG{n}{tiene} \PYG{n}{que} \PYG{n}{hacer} \PYG{n}{un} \PYG{n}{RET}\PYG{o}{.}
\PYG{o}{*} \PYG{n}{No} \PYG{n}{hacen} \PYG{n}{falta} \PYG{n}{operandos} \PYG{n}{extra}\PYG{p}{,} \PYG{n}{RET} \PYG{n}{no} \PYG{n}{requiere} \PYG{n}{nada} \PYG{n}{más}\PYG{o}{.}
\PYG{o}{*} \PYG{n}{Ya} \PYG{n}{se} \PYG{n}{tiene} \PYG{n}{el} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{código de instrucción completo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{así} \PYG{n}{que} \PYG{n}{se} \PYG{n}{ejecuta}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RET}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}
\end{sphinxVerbatim}

Un par de detalles a tener en cuenta:
\begin{itemize}
\item {} 
Como véis, el microprocesador no entiende el lenguaje ensamblador, sólo la traducción de este a Lenguaje Máquina (los números u opcodes que estamos viendo).

\item {} 
La primera parte leída de la instrucción es el OPCODE (código de operación), y es lo que permite al Spectrum, mediante una «tabla interna», saber qué tarea exacta tiene que realizar. Si la instrucción necesita datos extra para leer de memoria, se almacenan tras el opcode, y se conocen como «operandos». Así, «LD A, 00» se corresponde con la instrucción «3E 00», donde «3E» es el código de operación (opcode) y «00» es el operando.

\item {} 
Cuando un operando es de 16 bits (2 bytes), primero encontramos el byte bajo y luego el byte alto. Así, nuestro «LD DE, \$AABB» no se codifica como «11 AA BB» sino como «11 BB AA». El opcode para «LD DE» es «11», y «BB AA» los operandos (en este caso, un valor numérico directo). Esta forma de almacenamiento se denomina técnicamente «little endian».

\item {} 
Para el Spectrum, no hay diferencia entre instrucciones y datos. Un «\$3C» puede ser un «INC A» o un valor númerico «\$3C». ¿Cómo distingue el Spectrum uno de otro? Sencillo: todo depende de si se encuentra al principio de un ciclo de decodificación o no. Es decir, si cuando vamos a empezar a leer una instrucción leemos un «\$3C», es un INC A. Pero si lo leemos en el proceso de lectura de un operando, su significado cambia. Pensad en por ejemplo en «LD A, \$3C», que se codificaría como «3E 3C», pero no ejecutaría un INC A porque la lectura del «\$3C» se realiza como operando para el «LD A,».

\item {} 
Al no existir diferencia entre instrucciones y datos, si cambiamos PC de forma que apunte a una zona de la memoria donde hay datos y no código, el Z80 tratará de interpretar los números que va leyendo como si fueran opcodes (con resultados imprecedibles, seguramente con el cuelgue del Spectrum o un reset).

\item {} 
Por último, existen una serie de opcodes compuestos (dejando de lado los operandos) que ocupan más de 1 byte. Esos opcodes suelen comenzar por CB, ED o FD, de forma que, por ejemplo el opcode «CB 04» se corresponde con la operación «RLC L». Si sólo pudieramos utilizar un byte para representar el opcode, sólo tendríamos disponibles 256 posibles instrucciones en el procesador. Para poder disponer de más instrucciones se utilizan códigos de instrucción de más de un byte. Así, cuando nuestro procesador encuentra un CB, ED o FD sabe que el próximo código que lea después tendrá un significado diferente al que tendría sin el CB, ED o FD delante. Es por eso que «\$04» significa «INC B», y «\$CB \$04» significa «RLC L» (una instrucción diferente).

\end{itemize}


\section{Ensamblado manual}
\label{\detokenize{03_arquitectura/arquitectura:ensamblado-manual}}
Al igual que el Spectrum consulta una tabla interna para saber a qué instrucción corresponde cada valor numérico (cada opcode) nosotros podemos consultar una tabla para ensamblar manualmente nuestros programas en ensamblador y obtener los valores de código máquina con que se corresponden. Si no tenemos a mano un programa ensamblador que lo haga por nosotros (que, al fin y al cabo, no es más que un traductor «automático» con una tabla similar), podemos utilizar tablas de ensamblado para traducir el programa manualmente. Cabe decir que es una labor repetitiva y larga, y se recomienda encarecidamente la utilización de un programa ensamblador para ello.

Cuando lleguemos a la parte de definición del lenguaje veremos que ensamblando manualmente resulta bastante costoso calcular las direcciones de los saltos relativos y absolutos, cosa que el programa ensamblador hace con bastante facilidad.

Aún así, quien quiera intentar ensamblar manualmente podrá hacerlo incluso con la tabla de «Juego de caracteres» que tiene disponible en el manual del +2A/+3, capítulo 8, sección 28 (además de no ser la única tabla de ensamblado manual que existe, ya que hay varias disponibles en Internet).

\sphinxhref{https://sites.google.com/site/timeproofing/z80-instruction-set-1/z80-opcodes-sinclair?authuser=0}{Tabla de opcodes}.


\section{Tiempos de ejecución}
\label{\detokenize{03_arquitectura/arquitectura:tiempos-de-ejecucion}}
Cada instrucción necesita un tiempo diferente para ejecutarse. No es lo mismo un simple «INC A», que requiere leer un único byte como opcode, no requiere parámetros, y sólo realiza un incremento en un registro, que un complejo «LD A, (\$1234)», que requiere leer el opcode, a continuación leer 2 bytes para el operando «\$1234», después acceder a la memoria y extraer el dato contenido en (\$1234) para, finalmente, depositarlo en A.

Los tiempos de ejecución de cada instrucción son, pues, diferentes, y para conocerlos tendremos que consultar cualquier tabla de tiempos, medidos en t\sphinxhyphen{}states o t\sphinxhyphen{}estados. El t\sphinxhyphen{}estado o «ciclo del procesador», es la unidad de medida básica de tiempo. Podéis acceder a alguna de estas tablas en los enlaces que veréis al final de este artículo.


\section{El software de Spectrum}
\label{\detokenize{03_arquitectura/arquitectura:el-software-de-spectrum}}
A estas alturas ya debemos tener claro cómo funciona el Spectrum, con su microprocesador Z80 continuamente ejecutando el código apuntado por «PC», incrementando este y de nuevo repitiendo el ciclo.

Cuando encendemos nuestro Spectrum, PC vale 0000h y se ejecuta la ROM que, como ya hemos comentado, no es más que un programa hecho por los ingenieros que desarrollaron el Spectrum.

El código ensamblador de este «programa» está disponible para su consulta ya que usuarios de Spectrum realizaron un desensamblado (a partir de los opcodes, obtener el código fuente original) y comentaron todas las rutinas, variables del sistema y procedimientos que se ejecutan en nuestro Spectrum nada más arrancarlo. El libro «The Complete Spectrum ROM Disassembly» (El desensamblado Completo de la ROM del Spectrum) contiene este desensamblado, y podemos obtenerlo en Internet, por si tenemos curiosidad en conocer las interioridades de la ROM del Spectrum y cómo está programado el intérprete BASIC y las diferentes funciones de la ROM del mismo (con el objetivo de poder «usarlas» en nuestros programas en ensamblador).

Pero aparte de la ROM del Spectrum, ¿cómo llega a la memoria de nuestro ordenador (o emulador) los programas que ejecutamos?. Veamos las diferentes maneras:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Desde cinta: Nuestro LOAD «» provoca en BASIC la llamada a una rutina de la ROM que carga desde cinta el código y los datos de los programas. Lo único que se hace es leer de la cinta los opcodes y sus operandos, así como cualquier otro dato (gráficos, sonidos) del programa, e introducirlos en memoria en una zona a la que luego saltaremos (cambiaremos PC a ella). Cuando grabamos a cinta, lo que hacemos es leer el contenido de un trozo de memoria y escribirlo en cinta (escribir los valores numéricos de los opcodes, operandos y datos).

\item {} 
Desde disco: exactamente igual que en el caso de la cinta, pero el medio de almacenamiento es un disco de 3» o de 3.5».

\item {} 
Ficheros TAP y TZX: son ficheros de ordenador que almacenan los datos exactamente igual que si fuera una cinta real: almacenan opcodes, datos y operandos, que luego serán cargados en memoria.

\item {} 
Ficheros .SP, .SNA y .Z80 (en general, cualquier fichero de snapshot). No son más que volcados de la memoria. Por ejemplo, un fichero .SP o .SNA contiene el contenido de las 49152 celdillas de memoria desde 16384 hasta 65536. Para cargar ese .SNA en un emulador, lo que realiza el emulador es un simple «POKEado» del contenido del fichero en las celdillas de memoria. Así, un fichero snapshot no es más que una «copia» de la memoria (de su contenido) que volcamos a fichero.

\end{enumerate}

Cuando nosotros creemos un nuevo programa, lo haremos escribiendo el programa en un fichero de texto con instrucciones en ensamblador. La herramienta ensambladora «pasmo» convertirá este fichero con instrucciones (fichero.asm) en una ristra de bytes en código máquina (fichero.bin) con los opcodes y los datos de nuestro programa. Obtendremos pues un fichero binario que podremos almacenar en cinta, en tap, en tzx, etc.

Este fichero binario (esta ristra de bytes) podrá ser cargado en la memoria del Spectrum con cualquiera de los métodos que acabamos de ver y ejecutado saltando a la dirección de inicio donde haya sido cargado.


\section{En resumen}
\label{\detokenize{03_arquitectura/arquitectura:en-resumen}}
Hemos visto cómo funciona internamente nuestro ordenador Spectrum y el microprocesador Z80. A partir del próximo capítulo comenzaremos ya con la sintaxis del lenguaje ensamblador y una descripción de las diferentes instrucciones disponibles. No obstante, creemos que los conceptos introducidos ya en estos 2 primeros capítulos deben de haber llevado ya al lector a un punto en el cual podrá realizar sus primeras pruebas en ensamblador mediante la documentación a la cual nos referimos en los enlaces. Basta con consultar el juego de instrucciones del Spectrum en la página oficial del Z80 o de Zilog para poder realizar ya nuestros primeros programas en ensamblador para nuestro querido Sinclair ZX Spectrum.


\chapter{Lenguaje Ensamblador del Z80 (I)}
\label{\detokenize{04_lenguaje_ensamblador_01/lenguaje_ensamblador_01:lenguaje-ensamblador-del-z80-i}}\label{\detokenize{04_lenguaje_ensamblador_01/lenguaje_ensamblador_01::doc}}

\section{Arquitectura del Z80 e Instrucciones básicas}
\label{\detokenize{04_lenguaje_ensamblador_01/lenguaje_ensamblador_01:arquitectura-del-z80-e-instrucciones-basicas}}

\chapter{Indices y tablas}
\label{\detokenize{index:indices-y-tablas}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Índice}
\printindex
\end{document}