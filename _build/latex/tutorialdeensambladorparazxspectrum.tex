%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,spanish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsspanish{\renewcommand{\contentsname}{Contenidos:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Tutorial de ensamblador para ZX Spectrum}
\date{02 de marzo de 2021}
\release{1.0}
\author{Compiler Software}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Versión}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Prologo}
\label{\detokenize{01_prologo/prologo:prologo}}\label{\detokenize{01_prologo/prologo::doc}}
Mucha gente se preguntará cómo es posible que, en pleno 2011, exista alguien con interés en escribir y publicar un curso sobre esta temática. Apenas un par de centenares o miles de personas en todo el mundo pueden estar realmente interesadas en la lectura de un curso como este.

Sin embargo, he dedicado gran cantidad de horas a escribir y depurar este texto y sus ejemplos. ¿El motivo? Simplemente, no se me ocurre una mejor forma de concentrar en un único elemento mi pasión por el ZX Spectrum, la programación en ensamblador, el desarrollo de programas y los videojuegos.

Puedo y debo decir que el ZX Spectrum cambió mi vida. Aquella tarde de viernes de 1989 en la que mis padres aparecieron por la puerta con un Spectrum +2A de segunda mano, junto a una caja llena de revistas Microhobby y cintas de juegos y programas, cambió el que hubiera sido mi futuro profesional, orientándolo hacia el mundo de la Ingeniería, la Electrónica y las Telecomunicaciones.

Como todos, empecé exprimiendo el Spectrum a través de los juegos profesionales que se vendían para la popular máquina de Sinclair. En paralelo a los juegos, comencé a leer los ejemplares de las revistas Microhobby que habíamos adquirido junto al ordenador.

Mi relación inicial con Microhobby fue las que supongo que tendrían muchos usuarios sin interés por la programación: directo a las páginas con análisis, fotos y notas de juegos. Como mucho, como curiosidad tecleaba alguno de los listados en BASIC de la sección de trucos, maravillándome con sencillas melodías, o psicodélicos efectos de colores con el borde.

Esos listados en BASIC, tan sencillos, despertaron mi curiosidad por “cómo se hacen estos juegos”. Poco a poco se produjo el cambio: mi interés por jugar pasó a ser interés, mucho interés, por desarrollar.

Microhobby fue la herramienta mediante la cual aprendí BASIC y ensamblador de Z80. Como la completa revista que era, entre sus páginas de análisis de juegos podías encontrar fantásticos artículos y listados animándote a programar pequeñas rutinas y juegos.

Casi sin darme tiempo para disfrutar de lo que estaba aprendiendo, llegó el fin de la revista Microhobby y el ocaso comercial del Spectrum en España. Las consolas ocuparon el espacio lúdico del Spectrum y el PC se convirtió en la herramienta de programación estándar. El Spectrum pasó para mí al olvido hasta que la revista Micromanía publicó el emulador “SPECTRUM” de Pedro Gimeno.

Este emulador, y todos los que aparecieron en la década de los 90, sirvió para que la gente no olvidara el Spectrum y todo el legado que nos había dejado.

Ya a principios del siglo XXI, el Spectrum volvió a ser mi centro de atención: inicialmente, desarrollé el emulador ASpectrum con el que mejoré en gran parte mis conocimientos sobre la arquitectura del Spectrum y la programación en lenguaje ensamblador de Z80.

Una vez ASpectrum fue una realidad, comencé a realizar sencillos juegos con Z88DK en C con pequeñas rutinas en ensamblador integradas en el código. Se despertó de nuevo en mí el interés por desarrollar juegos de Spectrum y de escribir tutoriales y cursos con todo lo que iba rememorando o aprendiendo.

En esa época (años 2002 - 2003) se fundó Compiler Software y se editó la revista MagazineZX en el portal Speccy.org, incluyendo diversos cursos de programación en C con Z88DK y en ensamblador de Z80 con pasmo. Estos cursos, finalmente, se han ampliado y materializado en el texto que estáis leyendo.

Objetivos y desarrollo del curso

El objetivo principal de este curso, libro, o gran tutorial es que un lector con conocimientos básicos de programación pueda aprender fácilmente ensamblador de Z80 aplicado al desarrollo de juegos y utilidades de Spectrum.

Con este curso pretendemos enseñar al lector:
\begin{itemize}
\item {} 
La arquitectura del Sinclair ZX Spectrum: se describen sus componentes internos y cómo se interrelacionan.

\item {} 
La arquitectura del microprocesador Z80: sus registros y su juego de instrucciones.

\item {} 
La sintaxis del lenguaje ensamblador de Z80: nmemónicos del lenguaje.

\item {} 
Cómo utilizar el ensamblador PASMO para ensamblar nuestros programas en ASM de Z80.

\item {} 
Acceso a los periféricos del Spectrum: Teclado, Joystick, etc.

\item {} 
Gráficos en el Spectrum: Sprites, Fuentes de texto, Impresión de mapeados, etc.

\item {} 
Funciones avanzadas de los modelos 128K: paginación de memoria.

\item {} 
Rutinas auxiliares: subrutinas de carga, compresión RLE, interrupciones del procesador.

\item {} 
Subrutinas útiles para el desarrollo de programas.

\end{itemize}

Al escribirlo he intentado ponerme en la piel del programador que desea empezar con el lenguaje ensamblador, por lo que los dos primeros capítulos describen la arquitectura del Spectrum y del Z80. Los siguientes cinco capítulos tratan sobre la sintaxis del lenguaje ensamblador, donde el lector aprenderá las “piezas básicas” con las que construir programas en ensamblador para cualquier microordenador basado en el procesador Z80 de Zilog.

A partir del octavo capítulo nos centramos única y exclusivamente en el Spectrum, profundizando en todas las diferentes áreas que puedan sernos de utilidad para el desarrollo de juegos o programas: lectura del teclado, temporización, impresión de gráficos, técnicas de mapeado, carga desde cinta, etc.

A lo largo del texto se presentan múltiples ejemplos y rutinas para que el lector pueda verificar la teoría descrita así como utilizarlas directamente en sus propios programas.

Cuando se escribe una rutina para un procesador tan “limitado” como el Z80 suelen presentarse 2 opciones: escribir una rutina comprensible, o escribir una rutina optimizada. El objetivo del curso es que el lector aprenda programación en ensamblador y por lo tanto debe de poder comprender las rutinas que se presentan, por lo que en el desarrollo de los ejemplos y las rutinas ha primado la comprensión frente a la optimización en aquellos casos en que ambas opciones chocaban.

Esto no quiere decir que las rutinas no sean óptimas: al contrario, se han diseñado para que sean siempre lo más óptimas posible siempre y cuando eso no implique hacerlas incomprensibles para el lector. Aún así, un programador avanzado podrá (y deberá) darles una pequeña vuelta de tuerca adicional para exprimir ciclos de reloj a la rutina y hacerla aún un poco más rápida. Ese podría ser el objetivo del lector una vez acabado el curso y de cara al diseño de un programa.

Si un lector sin conocimientos de ensamblador, tras leer el curso, acaba decidiendo programar un juego y utiliza o mejora las rutinas que se presentan en este texto, podremos decir que el curso ha conseguido su objetivo.

Espero que disfrutéis tanto leyéndolo como yo escribiéndolo.


\chapter{Introducción y conceptos básicos}
\label{\detokenize{02_introduccion/introduccion:introduccion-y-conceptos-basicos}}\label{\detokenize{02_introduccion/introduccion::doc}}

\section{Los límites de BASIC}
\label{\detokenize{02_introduccion/introduccion:los-limites-de-basic}}
Todo aquel lector que haya programado en BASIC conocerá sin duda la principal limitación de este sencillo lenguaje de alto nivel: es lento, muy lento. A cambio de su sencillez pagamos una penalización enorme en velocidad.

BASIC es un lenguaje interpretado, lo que quiere decir que el Spectrum (más bien el intérprete BASIC integrado en la ROM) tiene que leer línea a línea nuestro programa, decodificar lo que estamos diciendo en lenguaje BASIC, traducirlo a instrucciones comprensibles por el procesador y ejecutarlo, todo ello en tiempo real.

Eso implica que cada vez que se ejecuta el programa BASIC, para cada línea del programa se ejecuta un proceso de lectura, decodificación, traducción y ejecución. Este proceso es lento e implica que no sólo se está ejecutando nuestro programa sino que debajo de él tenemos al intérprete de BASIC realizando todas estas tareas y restándonos parte de la potencia de CPU del Spectrum, que ya de por sí no es especialmente potente.

No importa lo elegantemente optimizado que esté nuestro programa en BASIC, el proceso de interpretación en sí hará que se ejecute con una lentitud que no podemos salvar.

BASIC tiene una serie de trucos más o menos conocidos para acelerar su ejecución: escribir muchas instrucciones en una sóla línea BASIC, poner las rutinas que más velocidad necesitan en las primeras líneas de programa, reducir el nombre (en longitud) de las variables, etc. Pero al final llegamos a un punto en que no podemos mejorar nuestros programas en cuanto a velocidad.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{basic}.gif}
\caption{El editor del intérprete de BASIC}\label{\detokenize{02_introduccion/introduccion:id1}}
\begin{sphinxlegend}\begin{quote}

Revisiones antiguas
Enlaces a esta página
Exportación a ODT
\end{quote}
\end{sphinxlegend}
\end{figure}

Tabla de Contenidos
Introducción y conceptos básicos

Los límites de BASIC

Todos aquel lector que haya programado en BASIC conocerá sin duda la principal limitación de este sencillo lenguaje de alto nivel: es lento, muy lento. A cambio de su sencillez pagamos una penalización enorme en velocidad.

BASIC es un lenguaje interpretado, lo que quiere decir que el Spectrum (más bien el intérprete BASIC integrado en la ROM) tiene que leer línea a línea nuestro programa, decodificar lo que estamos diciendo en lenguaje BASIC, traducirlo a instrucciones comprensibles por el procesador y ejecutarlo, todo ello en tiempo real.

Eso implica que cada vez que se ejecuta el programa BASIC, para cada línea del programa se ejecuta un proceso de lectura, decodificación, traducción y ejecución. Este proceso es lento e implica que no sólo se está ejecutando nuestro programa sino que debajo de él tenemos al intérprete de BASIC realizando todas estas tareas y restándonos parte de la potencia de CPU del Spectrum, que ya de por sí no es especialmente potente.

No importa lo elegantemente optimizado que esté nuestro programa en BASIC, el proceso de interpretación en sí hará que se ejecute con una lentitud que no podemos salvar.

BASIC tiene una serie de trucos más o menos conocidos para acelerar su ejecución: escribir muchas instrucciones en una sóla línea BASIC, poner las rutinas que más velocidad necesitan en las primeras líneas de programa, reducir el nombre (en longitud) de las variables, etc. Pero al final llegamos a un punto en que no podemos mejorar nuestros programas en cuanto a velocidad.

Lenguaje BASIC y su intérprete
El editor del intérprete de BASIC

Para muchos, el BASIC del Spectrum es un comienzo prácticamente obligado para programar, pero si queremos realizar programas con la calidad del software comercial no puede ser la herramienta a utilizar. Dejando de lado que sigue siendo una herramienta muy útil para programar en el Spectrum, para muchos llega la hora de dar el siguiente paso.


\chapter{Alternativas a BASIC}
\label{\detokenize{02_introduccion/introduccion:alternativas-a-basic}}
Aparte de realizar programas para el intérprete de BASIC existen múltiples alternativas para programar juegos y aplicaciones que expriman al máximo nuestra máquina:


\section{Subrutinas en ensamblador dentro de un programa BASIC}
\label{\detokenize{02_introduccion/introduccion:subrutinas-en-ensamblador-dentro-de-un-programa-basic}}
Para empezar, como primera opción, podemos realizar pequeñas rutinas en ensamblador y utilizarlas desde nuestros programas en BASIC. El lenguaje ensamblador se trata del lenguaje más cercano a lo que es el código binario que entiende directamente un microprocesador. Es de bajo nivel, es decir, está más lejos del lenguaje humano de lo que está BASIC, y a la vez está muy cerca del lenguaje que entiende el microprocesador de nuestro Spectrum.

En BASIC, una instrucción es traducida por el intérprete BASIC a una serie más o menos larga de comandos en lenguaje máquina. Por ejemplo, 10 PRINT «HOLA», se traduce como una serie de comandos en lenguaje máquina que podrían ser algo como «para cada una de las letras de la palabra HOLA, realiza todas las operaciones necesarias para mostrar en pantalla todos los píxels que forman dichas letras, actualizando la posición del cursor y usando el color INK y PAPER actual».

Una instrucción BASIC equivale a una gran cantidad de instrucciones en código máquina.

Por contra, una instrucción en lenguaje ensamblador equivale a una sóla instrucción en lenguaje máquina: hablamos directamente el lenguaje de la máquina, sólo que en vez de hacerlo con unos y ceros, lo hacemos en un lenguaje que tiene unas determinadas reglas de sintaxis y que el «programa ensamblador» se encarga de traducir a código máquina. Es por eso que programar en ensamblador es de «bajo nivel»: hablamos directamente al nivel de la máquina, y por eso mismo los programas son más complicados de escribir, de leer y de mantener que un programa en BASIC, donde se habla un lenguaje más natural y que es traducido a lo que la máquina entiende.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
   \PYG{c+c1}{;}
   \PYG{c+c1}{; Rutina de multiplicación en lenguaje ensamblador:}
   \PYG{c+c1}{;}
   \PYG{c+c1}{; MULTIPLICA: Multiplica DE*BC}
   \PYG{c+c1}{;}
   \PYG{c+c1}{;       Entrada:        DE: Multiplicando,}
   \PYG{c+c1}{;                       BC: Multiplicador}
   \PYG{c+c1}{;       Salida:         HL: Resultado.}

   \PYG{n+nl}{MULTIPLICA:}
           \PYG{n+nf}{LD} \PYG{n+nv}{HL}\PYG{p}{,} \PYG{l+m+mi}{0}            \PYG{c+c1}{; HL = 0}
   \PYG{n+nl}{MULTI01:}
           \PYG{n+nf}{ADD} \PYG{n+nv}{HL}\PYG{p}{,} \PYG{n+nv}{DE}          \PYG{c+c1}{; Sumamos HL = HL + DE}
           \PYG{n+nf}{DEC} \PYG{n+nv}{BC}
           \PYG{n+nf}{LD} \PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}
           \PYG{n+nf}{OR} \PYG{n+nv}{C}
           \PYG{n+nf}{JR} \PYG{n+nv}{NZ}\PYG{p}{,} \PYG{n+nv}{MULTI01}      \PYG{c+c1}{; Lo repetimos BC veces}
           \PYG{n+nf}{RET}                 \PYG{c+c1}{; Volver de la rutina}


\PYG{n+nf}{La} \PYG{n+nv}{primera} \PYG{n+nv}{de} \PYG{n+nv}{las} \PYG{n+nv}{opciones} \PYG{n+nv}{que} \PYG{n+nb}{es}\PYG{n+nv}{tamos} \PYG{n+nv}{tratando}\PYG{p}{,} \PYG{n+nv}{la} \PYG{n+nv}{de} \PYG{n+nv}{programar} \PYG{n+nv}{rutinas} \PYG{n+nv}{en} \PYG{n+nv}{ensamblador} \PYG{n+nv}{y} \PYG{n+nv}{utilizarlas} \PYG{n+nv}{después} \PYG{n+nv}{desde} \PYG{n+nv}{programas} \PYG{n+nv}{en} \PYG{n+nv}{BASIC} \PYG{o+ow}{seg}\PYG{n+nv}{uiría} \PYG{n+nv}{el} \PYG{n+nb}{si}\PYG{n+nv}{guiente} \PYG{n+nv}{ciclo} \PYG{n+nv}{de} \PYG{n+nv}{desarrollo}\PYG{p}{:}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Programamos una rutina en lenguaje ensamblador que realice una función concreta: por ejemplo, dibujar el personaje o enemigos de nuestro juego, borrar la pantalla, actualizar los marcadores, etc.

\item {} 
Ensamblamos la rutina con un programa ensamblador y obtenemos un bloque de datos que contiene la traducción del programa que hemos escrito a código máquina directamente comprensible por el microprocesador.

\item {} 
Cargamos en memoria el bloque de datos de código máquina que acabamos de obtener mediante un LOAD «» CODE o POKEando cada byte de este bloque de datos en memoria.

\item {} 
Programamos nuestro programa en BASIC, y llamamos a la rutina que hemos programando cuando la necesitemos utilizando RANDOMIZE USR hacia la dirección en que hemos cargado o POKEado la rutina.

\end{itemize}

Es decir: realizamos una rutina o un conjunto de rutinas en ensamblador y mediante un programa ensamblador, traducimos el código ASM a código que entiende directamente la máquina (código binario) y lo salvamos en cinta (o si es corto, anotamos sus valores para meterlos en DATAs). Después, al inicio de nuestro programa, introducimos ese código binario en memoria de forma que lo podamos llamar en cualquier momento desde BASIC con RANDOMIZE USR.

Esto permite realizar rutinas importantes y críticas en lenguaje ensamblador, y mantener el esqueleto del programa principal en BASIC. Las rutinas creadas en ensamblador son llamadas desde BASIC con la instrucción \sphinxstylestrong{USR} en aquellos puntos del programa en que las necesitemos.

Más adelante en este capítulo veremos un ejemplo de cómo realizar el ensamblado de una rutina en ensamblador, su carga en memoria y su utilización desde un programa en BASIC.


\section{Compilando el programa BASIC con un compilador}
\label{\detokenize{02_introduccion/introduccion:compilando-el-programa-basic-con-un-compilador}}
Aunque utilicemos rutinas en ensamblador llamadas desde BASIC, seguiremos lastrados por la velocidad del intérprete y los tiempos de ejecución de las partes del programa que no están escritas en ensamblador.

Como una segunda opción alternativa a la integración BASIC-ASM, tenemos la opción de utilizar un compilador de BASIC para compilar nuestros programas y traducirlos a código máquina sin pasar por ningún intérprete de BASIC.

Mediante un compilador de BASIC, a partir de un programa de código fuente en BASIC obtenemos un ejecutable que podremos cargar directamente en memoria y ejecutarlo sin necesidad de utilizar el intérprete del sistema.

La labor de interpretación del código BASIC se hace igualmente, pero se hace antes, ya que en lugar de ejecutar, el resultado de la interpretación se graba ya «traducido» en cinta. Un programa en BASIC compilado y ejecutado de este modo es muchísimo más rápido que el mismo programa ejecutado en el intérprete de BASIC del Spectrum.

\sphinxstylestrong{MCODER}, uno de los compiladores nativos de BASIC más conocidos, es una buena solución, y para muchos puede ser suficiente para muchas de sus creaciones. Nuestra querida DINAMIC realizó sus primeros juegos en BASIC con MCODER: hablamos de Babaliba, Saimazoom, o la utilidad Artist. MCODER tiene unas limitaciones que no tienen porqué ser especialmente problemáticas si las conocemos, las aceptamos, y realizamos nuestros programas teniéndolas en cuenta. Por ejemplo, no podemos utilizar vectores (creados con DIM en BASIC), y el manejo de cadenas sufre algunos cambios de sintaxis, entre otros.

La principal desventaja de MCODER es que es un compilador BASIC nativo, es decir, que es software para Spectrum que debemos ejecutar dentro de un emulador o la máquina real lo que nos puede ralentizar a la hora de programar.

Una opción mucho más aconsejable es la de utilizar un compilador cruzado como \sphinxstylestrong{ZX Basic Compiler} (ZXB Compiler).

Un \sphinxstylestrong{compilador cruzado} es un compilador que se ejecuta en una plataforma diferente de la plataforma destino, pero genera código para ésta. Por ejemplo, podemos escribir nuestro programa BASIC en un editor de textos en un PC (fuera del Spectrum), compilarlo con un compilador cruzado, y obtener un binario con código máquina de Spectrum, listo para ser ejecutado en un emulador o en una máquina real. De esta forma nos beneficiamos de las mayores capacidades de nuestra plataforma de desarrollo (un PC) para conseguir código compilado para un Spectrum.

En este caso, el compilador cruzado ZX Basic Compiler permite compilar programas escritos en un dialecto BASIC estándar y genera un fichero de instrucciones en ensamblador que podemos ensamblar con ensambladores cruzados.

El ciclo de desarrollo para la compilación de programas BASIC sería similar al siguiente:
\begin{itemize}
\item {} 
Programamos nuestro juego en lenguaje BASIC escribiendo el programa en un editor de textos estándar de nuestra plataforma de desarrollo.

\item {} 
Grabamos el código de nuestro programa como un fichero .BAS.

\item {} 
Mediante el compilador cruzado, compilamos el fichero .BAS y obtenemos un fichero binario de código máquina, normalmente con un cargador BASIC incluído al principio del mismo.

\item {} 
Cargamos ese código máquina en nuestro Spectrum o emulador con un simple LOAD «».

\item {} 
El programa se carga y ejecuta como cualquier otro juego comercial.

\end{itemize}

Es una opción muy interesante para quien quiera seguir programando en BASIC y obtener la potencia que el intérprete de BASIC le resta.


\section{Programando en Lenguaje C}
\label{\detokenize{02_introduccion/introduccion:programando-en-lenguaje-c}}
Otra opción es la de aprender lenguaje C y realizar programas íntegramente en C que son compilados (al igual que hace ZX Basic Compiler) y trasladados a código binario que ejecutará el Spectrum.

Podemos ver el lenguaje C (en el Spectrum) como una manera de realizar programas bastante rápidos saltándonos las limitaciones de BASIC. No llega a ser ensamblador, pero desde luego es mucho más rápido que BASIC (y que BASIC compilado).

C es un lenguaje muy potente y de alto nivel que genera un código bastante óptimo y cuyos binarios tienen una velocidad de ejecución muchísimo más cercana a la de programas en ensamblador que a la de programas BASIC interpretados.

El desarrollo de un juego o programa en C se realizaría de forma similar al caso de los compiladores BASIC:
\begin{itemize}
\item {} 
Programamos nuestro juego en lenguaje C escribiendo el programa en un editor de textos estándar de nuestra plataforma de desarrollo.

\item {} 
Grabamos el código de nuestro programa como un fichero .C .

\item {} 
Mediante el compilador cruzado, compilamos el fichero .C y obtenemos un fichero binario de código máquina, normalmente con un cargador BASIC incluído al principio del mismo.

\item {} 
Cargamos ese código máquina en nuestro Spectrum o emulador con un simple LOAD «».

\item {} 
El programa se carga y ejecuta como cualquier otro juego comercial.

\end{itemize}

Para quien ya conozca el lenguaje C y se desenvuelva bien con él, utilizar un compilador cruzado como pueda serlo Z88DK será sin duda un gran opción. Programando en C se puede hacer prácticamente cualquier aplicación y un gran número de juegos.

Además, se puede embeber código ensamblador dentro de las rutinas en C, con lo cual se puede decir que no estamos limitados por el lenguaje C a la hora de realizar tareas que requieren un control muy preciso de la máquina.


\section{Realizando el programa completo en ensamblador.}
\label{\detokenize{02_introduccion/introduccion:realizando-el-programa-completo-en-ensamblador}}
Finalmente, la última opción: nos hemos decidido y queremos escribir programas directamente en el lenguaje que comprende la máquina, ya que queremos controlar todo lo que realiza el microprocesador.

Con la opción que hemos elegido, escribiremos el código del programa íntegramente en lenguaje ensamblador (assembler language en inglés, o ASM para abreviar).

Con BASIC compilado y con C, es el compilador quien transforma nuestros comandos en código máquina. En el lenguaje ensamblador, la «compilación» (conocida como proceso de ensamblado) del programa en código máquina es una mera traducción ya que cada instrucción en ensamblador se traduce en una instrucción en código máquina, como veremos más adelante.

Para programar en ensamblador seguiremos el siguiente proceso:
\begin{itemize}
\item {} 
Programamos nuestro juego en lenguaje ensamblador escribiendo el programa en un editor de textos estándar de nuestra plataforma de desarrollo.

\item {} 
Grabamos el código de nuestro programa como un fichero .ASM .

\item {} 
Mediante el ensamblador cruzado, ensamblamos el fichero .ASM y obtenemos un fichero binario de código máquina, normalmente con un cargador BASIC incluído al principio del mismo.

\item {} 
Cargamos ese código máquina en nuestro Spectrum o emulador con un simple LOAD «».

\item {} 
El programa se carga y ejecuta como cualquier otro juego comercial.

\end{itemize}

Es importante destacar que el desarrollo de un programa en ASM requiere mucho más tiempo, un mejor diseño y muchos más conocimientos del hardware que utilizar cualquier otro lenguaje. Un programa en BASIC sencillo puede tener 1000 líneas, pero el mismo programa en ASM puede tener perfectamente 10000, 50000, o muchas más líneas.

En ensamblador no tenemos funciones de alto nivel que realicen determinadas tareas por nosotros: no existe PRINT para imprimir cosas por pantalla, si queremos imprimir texto tenemos que imprimir una a una las letras, calculando posiciones, píxeles, colores, y escribiendo en la videomemoria nosotros mismos. Podemos apoyarnos en una serie de rutinas que hay en la ROM del Spectrum (que son las que utiliza BASIC), pero en general, para la mayoría de las tareas, lo tendremos que hacer todo manualmente.

Un ejemplo muy sencillo: en BASIC podemos multiplicar 2 números de forma muy simple con el operador «*». En ensamblador, no existe un comando para multiplicar 2 números. No existe dicho comando porque el micro Z80 tiene definida la operación de suma (ADD) y la de resta (SUB), por ejemplo, pero no tiene ninguna instrucción para multiplicar o dividir. Y si queremos multiplicar 2 números, tendremos que hacer una rutina en ensamblador que lo haga (como la rutina que hemos visto en el apartado anterior) y llamarla cada vez que necesitemos realizar una multiplicación.

Es posible que el anterior párrafo parezca demasiado «duro» para los programadores acostumbrados a BASIC y que lo anteriormente explicado parezca un panorama desolador, pero esa es la realidad con el ensamblador: cada instrucción en ensamblador se corresponde con una instrucción de la CPU Z80. Si se quiere hacer algo más complejo que lo que permite directamente la CPU, nos lo hemos de construir nosotros mismos a base de utilizar esas instrucciones. Una multiplicación se puede realizar como una serie de sumas, por ejemplo, como hemos visto en la rutina MULT del apartado anterior.

Descrito visualmente, en BASIC para construir una casa te dan paredes completas, ventanas, escaleras y puertas, y combinándolos te construyes la casa. En ASM, por contra, lo que te dan es un martillo, clavos, un cincel, madera y roca, y a partir de eso tienes que construir tú todos los elementos del programa.

Obviamente, no tendremos que escribir miles de rutinas antes de poder programar cualquier cosa: existen rutinas ya disponibles que podemos aprovechar. En Internet, en revistas Microhobby, en libros de programación de Z80, en la ROM del Spectrum, encontraremos rutinas listas para utilizar y que nos permitirán multiplicar, dividir, imprimir cadenas de texto, y muchas otras cosas.

Además, cada nueva rutina que programemos podremos reutilizarla en futuros programas, por lo que el inicio es duro pero a partir de cierto momento dispondremos de bibliotecas de rutinas que podremos integrar en nuestros programas para reducir el tiempo de desarrollo.


\chapter{Indices y tablas}
\label{\detokenize{index:indices-y-tablas}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Índice}
\printindex
\end{document}